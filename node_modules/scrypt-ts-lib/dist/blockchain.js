"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
const scrypt_ts_1 = require("scrypt-ts");
const merklePath_1 = require("./merklePath");
class Blockchain extends scrypt_ts_1.SmartContractLib {
    // SPV: Is a txid in a block
    static txInBlock(txid, bh, merkleProof, depth) {
        return (merklePath_1.MerklePath.calcMerkleRoot(txid, merkleProof, depth) == bh.merkleRoot);
    }
    // Is txid the last transaction in a block
    static lastTxInBlock(txid, bh, merkleProof, depth) {
        let last = true;
        let root = txid;
        for (let i = 0; i < depth; i++) {
            const node = merkleProof[i];
            if (node.pos != merklePath_1.MerklePath.INVALID_NODE) {
                // IF LAST ELEMENT:
                // - A non-duplicate node cannot ever be on the right.
                const isDuplicate = node.hash == root;
                if (!isDuplicate && node.pos == merklePath_1.MerklePath.RIGHT_NODE) {
                    last = false;
                }
                root = (0, scrypt_ts_1.Sha256)(node.pos == merklePath_1.MerklePath.LEFT_NODE
                    ? (0, scrypt_ts_1.hash256)(node.hash + root)
                    : (0, scrypt_ts_1.hash256)(root + node.hash));
            }
        }
        return last && root == bh.merkleRoot;
    }
    // TODO:
    // The function below assumes there cannot be any duplicate nodes on the left-hand side,
    // which is false.
    //// Calculate a tx's index in a block from its merkle path.
    //// Goes from top to bottom, the path basically encodes the index in binary form.
    //// left/L means 1, and right/R 0: e.g., (L, R, L) denotes 101 in binary, and 5 in decimal
    //@method()
    //static txIndex(merkleProof: MerkleProof): bigint {
    //    let sum = 0n
    //    // traverse the path from top to bottom
    //    for (let i = 0; i < MerklePath.DEPTH; i++) {
    //        const node = merkleProof[Number(MerklePath.DEPTH) - i - 1]
    //        if (node.pos != MerklePath.INVALID_NODE) {
    //            sum *= 2n
    //            if (node.pos == MerklePath.LEFT_NODE) {
    //                sum++
    //            }
    //        }
    //    }
    //    return sum
    //}
    //// Get number of transactions in a block.
    //@method()
    //static blockTxCount(
    //    bh: BlockHeader,
    //    lastTxid: Sha256,
    //    merkleProof: MerkleProof
    //): bigint {
    //    // Ensure this tx is indeed the last one.
    //    assert(Blockchain.lastTxInBlock(lastTxid, bh, merkleProof))
    //    return Blockchain.txIndex(merkleProof) + 1n
    //}
    // Is block header valid with difficulty meeting target.
    static isValidBlockHeader(bh, blockchainTarget) {
        const bhHash = Blockchain.blockHeaderHashAsInt(bh);
        const target = Blockchain.bits2Target(bh.bits);
        // Block hash below target and target below blockchain difficulty target.
        return bhHash <= target && target <= blockchainTarget;
    }
    static verifyBlockHeader(bh) {
        const bhHash = Blockchain.blockHeaderHashAsInt(bh);
        const target = Blockchain.bits2Target(bh.bits);
        // Block hash below target
        return bhHash <= target;
    }
    // Is a chain of block headers valid.
    // TODO
    // Is raw transaction a coinbase tx.
    static isCoinbase(tx) {
        return ((0, scrypt_ts_1.slice)(tx, 4n, 5n) == (0, scrypt_ts_1.toByteString)('01') && // only 1 input
            (0, scrypt_ts_1.slice)(tx, 5n, 37n) ==
                (0, scrypt_ts_1.toByteString)('0000000000000000000000000000000000000000000000000000000000000000') && // null txid: all zeros
            (0, scrypt_ts_1.slice)(tx, 37n, 41n) == (0, scrypt_ts_1.toByteString)('ffffffff')); // null vout: all Fs
    }
    // Get height of the block identified by the header.
    static blockHeight(bh, coinbaseTx, merkleProof, depth) {
        // Ensure coinbase it's in the block.
        (0, scrypt_ts_1.assert)(Blockchain.txInBlock((0, scrypt_ts_1.Sha256)((0, scrypt_ts_1.hash256)(coinbaseTx)), bh, merkleProof, depth));
        // Ensure it's the coinbase.
        (0, scrypt_ts_1.assert)(merklePath_1.MerklePath.isCoinbase(merkleProof, depth));
        return Blockchain.readBlockHeight(coinbaseTx);
    }
    // Parse block height from coinbase tx: BIP34
    static readBlockHeight(coinbaseTx) {
        // Block height is at the beginning of the unlocking script and encoded in varint.
        return scrypt_ts_1.Utils.fromLEUnsigned(scrypt_ts_1.Utils.readVarint((0, scrypt_ts_1.slice)(coinbaseTx, Blockchain.BLOCK_HEIGHT_POS)));
    }
    // Convert difficulty from bits to target.
    static bits2Target(bits) {
        const exponent = scrypt_ts_1.Utils.fromLEUnsigned((0, scrypt_ts_1.slice)(bits, 3n));
        const coefficient = scrypt_ts_1.Utils.fromLEUnsigned((0, scrypt_ts_1.slice)(bits, 0n, 3n));
        const n = 8n * (exponent - 3n);
        return (0, scrypt_ts_1.lshift)(coefficient, n);
    }
    // Serialize a block header.
    static serialize(bh) {
        return (bh.version +
            bh.prevBlockHash +
            bh.merkleRoot +
            scrypt_ts_1.Utils.toLEUnsigned(bh.time, 4n) +
            bh.bits +
            scrypt_ts_1.Utils.toLEUnsigned(bh.nonce, 4n));
    }
    static deserialize(bh) {
        return {
            version: (0, scrypt_ts_1.slice)(bh, 0n, 4n),
            prevBlockHash: (0, scrypt_ts_1.Sha256)((0, scrypt_ts_1.slice)(bh, 4n, 36n)),
            merkleRoot: (0, scrypt_ts_1.Sha256)((0, scrypt_ts_1.slice)(bh, 36n, 68n)),
            time: scrypt_ts_1.Utils.fromLEUnsigned((0, scrypt_ts_1.slice)(bh, 68n, 72n)),
            bits: (0, scrypt_ts_1.slice)(bh, 72n, 76n),
            nonce: scrypt_ts_1.Utils.fromLEUnsigned((0, scrypt_ts_1.slice)(bh, 76n, 80n)),
        };
    }
    // Block header hash.
    static blockHeaderHash(bh) {
        return (0, scrypt_ts_1.hash256)(Blockchain.serialize(bh));
    }
    // Block header hash, but converted to a positive integer.
    static blockHeaderHashAsInt(bh) {
        return scrypt_ts_1.Utils.fromLEUnsigned(Blockchain.blockHeaderHash(bh));
    }
}
exports.Blockchain = Blockchain;
// Block height's position relative to the beginning of coinbase tx.
// TODO: This assumes unlocking script can be pushed using OP_PUSH_1. See if it always holds?
Blockchain.BLOCK_HEIGHT_POS = 42n;
__decorate([
    (0, scrypt_ts_1.prop)()
], Blockchain, "BLOCK_HEIGHT_POS", void 0);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "txInBlock", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "lastTxInBlock", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "isValidBlockHeader", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "verifyBlockHeader", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "isCoinbase", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "blockHeight", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "readBlockHeight", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "bits2Target", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "serialize", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "deserialize", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "blockHeaderHash", null);
__decorate([
    (0, scrypt_ts_1.method)()
], Blockchain, "blockHeaderHashAsInt", null);
//# sourceMappingURL=blockchain.js.map