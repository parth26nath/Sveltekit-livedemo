"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schnorr = void 0;
const scrypt_ts_1 = require("scrypt-ts");
const secp256k1_1 = require("./ec/secp256k1");
// Schnorr signatures verification for secp256k1
class Schnorr extends scrypt_ts_1.SmartContractLib {
    // s * G = R + hash(r, P, m) * P
    static verify(sig, pubKey, msg, R) {
        const r = (0, scrypt_ts_1.slice)(sig, 0n, 32n); // First 32 bytes
        const s = (0, scrypt_ts_1.byteString2Int)((0, scrypt_ts_1.reverseByteString)((0, scrypt_ts_1.slice)(sig, 32n, 64n), 32n) + (0, scrypt_ts_1.toByteString)('00'));
        // e = Hash(r || P || msg)
        let e = (0, scrypt_ts_1.byteString2Int)((0, scrypt_ts_1.reverseByteString)((0, scrypt_ts_1.sha256)(r + pubKey + msg), 32n) +
            (0, scrypt_ts_1.toByteString)('00'));
        e = secp256k1_1.SECP256K1.modReduce(e, secp256k1_1.SECP256K1.n);
        // E = e * P
        const P = secp256k1_1.SECP256K1.pubKey2Point(pubKey);
        const E = secp256k1_1.SECP256K1.mulByScalar(P, e);
        // A = R + E
        const A = secp256k1_1.SECP256K1.addPoints(R, E);
        // S = s * G
        const S = secp256k1_1.SECP256K1.mulGeneratorByScalar(s);
        // S == A
        return secp256k1_1.SECP256K1.comparePoints(S, A);
    }
}
exports.Schnorr = Schnorr;
__decorate([
    (0, scrypt_ts_1.method)()
], Schnorr, "verify", null);
//# sourceMappingURL=schnorr.js.map