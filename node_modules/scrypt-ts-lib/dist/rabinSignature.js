"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WitnessOnChainVerifier = exports.RabinVerifier = void 0;
const scrypt_ts_1 = require("scrypt-ts");
const rabinsig_1 = require("rabinsig");
class RabinVerifier extends scrypt_ts_1.SmartContractLib {
    static expandHash(x) {
        // expand into 512 bit hash
        const hx = (0, scrypt_ts_1.sha256)(x);
        return (0, scrypt_ts_1.sha256)((0, scrypt_ts_1.slice)(hx, 0n, 16n)) + (0, scrypt_ts_1.sha256)((0, scrypt_ts_1.slice)(hx, 16n));
    }
    static hash(x) {
        let result = RabinVerifier.expandHash(x);
        for (let i = 0; i < RabinVerifier.SECURITY_LEVEL - 1; i++) {
            result += RabinVerifier.expandHash(result);
        }
        return result;
    }
    static verifySig(msg, sig, pubKey) {
        const h = scrypt_ts_1.Utils.fromLEUnsigned(RabinVerifier.hash(msg + sig.padding));
        return (sig.s * sig.s) % pubKey == h % pubKey;
    }
}
exports.RabinVerifier = RabinVerifier;
RabinVerifier.SECURITY_LEVEL = 6;
__decorate([
    (0, scrypt_ts_1.method)()
], RabinVerifier, "expandHash", null);
__decorate([
    (0, scrypt_ts_1.method)()
], RabinVerifier, "hash", null);
__decorate([
    (0, scrypt_ts_1.method)()
], RabinVerifier, "verifySig", null);
/**
 * Rabin signature verifier for WitnessOnChain.
 * @see {@link https://api.witnessonchain.com }
 */
class WitnessOnChainVerifier extends scrypt_ts_1.SmartContractLib {
    static verifySig(msg, sig, pubKey) {
        return RabinVerifier.verifySig(msg, sig, pubKey);
    }
    static parseMsg(response) {
        return (0, scrypt_ts_1.toByteString)(response.data);
    }
    static parsePubKey(response) {
        return scrypt_ts_1.Utils.fromLEUnsigned(response.publicKey);
    }
    static parseSig(response) {
        return (0, rabinsig_1.toRabinSig)((0, rabinsig_1.deserialize)(response.signature));
    }
}
exports.WitnessOnChainVerifier = WitnessOnChainVerifier;
__decorate([
    (0, scrypt_ts_1.method)()
], WitnessOnChainVerifier, "verifySig", null);
//# sourceMappingURL=rabinSignature.js.map