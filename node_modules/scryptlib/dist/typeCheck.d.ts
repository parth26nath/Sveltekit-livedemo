import { Argument, Arguments, LibraryEntity, ParamEntity, StructEntity } from '.';
import { AliasEntity, StaticEntity } from './internal';
import { SupportedParamType, TypeInfo, TypeResolver } from './scryptTypes';
export declare function typeOfArg(a: SupportedParamType): string;
/**
 * return eg. int[N][N][4] => ['int', ["N","N","4"]]
 * @param arrayTypeName
 */
export declare function arrayTypeAndSizeStr(arrayTypeName: string): [string, Array<string>];
/**
 * return eg. int[2][3][4] => ['int', [2,3,4]]
 * @param arrayTypeName  eg. int[2][3][4]
 */
export declare function arrayTypeAndSize(arrayTypeName: string): [string, Array<number>];
export declare function toLiteralArrayType(elemTypeName: string, sizes: Array<number | string>): string;
/**
 * return eg. int[2][3][4] => int[3][4]
 * @param arrayTypeName  eg. int[2][3][4]
 */
export declare function subArrayType(arrayTypeName: string): string;
export declare function checkSupportedParamType(arg: SupportedParamType, param: ParamEntity, resolver: TypeResolver): Error | undefined;
export declare function hasGeneric(entity: StructEntity | LibraryEntity): boolean;
export declare function deduceGenericStruct(param: ParamEntity, entity: StructEntity, resolver: TypeResolver): StructEntity | LibraryEntity | Error;
export declare function deduceGenericLibrary(param: ParamEntity, entity: LibraryEntity, resolver: TypeResolver): LibraryEntity | Error;
export type FlatOptions = {
    state: boolean;
    ignoreValue: boolean;
};
export declare function flatternArg(arg: Argument, resolver: TypeResolver, options: FlatOptions): Arguments;
export declare function findConstStatic(statics: StaticEntity[], name: string): StaticEntity | undefined;
export declare function findStatic(statics: StaticEntity[], name: string): StaticEntity | undefined;
export declare function resolveType(type: string, originTypes: Record<string, TypeInfo>, contract: string, statics: StaticEntity[], alias: AliasEntity[], librarys: LibraryEntity[]): TypeInfo;
/**
 * check if a type is generic type
 * @param type
 * @returns
 */
export declare function isGenericType(type: string): boolean;
/**
 *
 * @param type eg. HashedMap<int,int>
 * @param eg. ["HashedMap", ["int", "int"]}] An array generic types returned by @getGenericDeclaration
 * @returns {"K": "int", "V": "int"}
 */
export declare function parseGenericType(type: string): [string, Array<string>];
export declare function resolveGenericType(genericTypeMap: Record<string, string>, type: string): string;
