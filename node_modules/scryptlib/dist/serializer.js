"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toScriptASM = exports.toScriptHex = exports.bytes2hex = exports.bool2hex = exports.int2hex = void 0;
var scryptTypes_1 = require("./scryptTypes");
var utils_1 = require("./utils");
var BN = utils_1.bsv.crypto.BN;
/**
 * int to little-endian signed magnitude
 */
function int2hex(n) {
    if (n === (0, scryptTypes_1.Int)(0)) {
        return '00';
    }
    else if (n === (0, scryptTypes_1.Int)(-1)) {
        return '4f';
    }
    else if (n > (0, scryptTypes_1.Int)(0) && n <= (0, scryptTypes_1.Int)(16)) {
        n += (0, scryptTypes_1.Int)(80);
        return n.toString(16);
    }
    var number = new BN(n);
    var m = number.toSM({ endian: 'little' });
    return utils_1.bsv.Script.fromASM(m.toString('hex')).toHex();
}
exports.int2hex = int2hex;
function bool2hex(b) {
    if (b) {
        return '51';
    }
    return '00';
}
exports.bool2hex = bool2hex;
function bytes2hex(b) {
    if (b) {
        if (b.length / 2 > 1) {
            return utils_1.bsv.Script.fromASM(b).toHex();
        }
        var intValue = parseInt(b, 16);
        if (intValue >= 1 && intValue <= 16) {
            return BigInt(intValue + 80).toString(16);
        }
        return utils_1.bsv.Script.fromASM(b).toHex();
    }
    return '00';
}
exports.bytes2hex = bytes2hex;
function toScriptHex(x, type) {
    if (type === scryptTypes_1.ScryptType.INT || type === scryptTypes_1.ScryptType.PRIVKEY) {
        return int2hex(x);
    }
    else if (type === scryptTypes_1.ScryptType.BOOL) {
        return bool2hex(x);
    }
    else if ((0, scryptTypes_1.isBytes)(type)) {
        return bytes2hex(x);
    }
    throw new Error("unsupport SupportedParamType: ".concat(x));
}
exports.toScriptHex = toScriptHex;
function toScriptASM(a, type) {
    var hex = toScriptHex(a, type);
    return utils_1.bsv.Script.fromHex(hex).toASM();
}
exports.toScriptASM = toScriptASM;
//# sourceMappingURL=serializer.js.map