"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ABICoder = exports.FunctionCall = void 0;
var builtins_1 = require("./builtins");
var compilerWrapper_1 = require("./compilerWrapper");
var contract_1 = require("./contract");
var deserializer_1 = require("./deserializer");
var launchConfig_1 = require("./launchConfig");
var scryptTypes_1 = require("./scryptTypes");
var serializer_1 = require("./serializer");
var stateful_1 = require("./stateful");
var typeCheck_1 = require("./typeCheck");
var utils_1 = require("./utils");
var FunctionCall = /** @class */ (function () {
    function FunctionCall(methodName, binding) {
        this.methodName = methodName;
        this.args = [];
        if (binding.lockingScript === undefined && binding.unlockingScript === undefined) {
            throw new Error('param binding.lockingScript & binding.unlockingScript cannot both be empty');
        }
        this.contract = binding.contract;
        this.args = binding.args;
        if (binding.lockingScript) {
            this._lockingScript = binding.lockingScript;
        }
        if (binding.unlockingScript) {
            this._unlockingScript = binding.unlockingScript;
        }
    }
    Object.defineProperty(FunctionCall.prototype, "unlockingScript", {
        get: function () {
            return this._unlockingScript;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FunctionCall.prototype, "lockingScript", {
        get: function () {
            return this._lockingScript;
        },
        set: function (s) {
            this._lockingScript = s;
        },
        enumerable: false,
        configurable: true
    });
    FunctionCall.prototype.toASM = function () {
        return this.toScript().toASM();
    };
    FunctionCall.prototype.toString = function () {
        return this.toHex();
    };
    FunctionCall.prototype.toScript = function () {
        if (this.lockingScript) {
            return this.lockingScript;
        }
        else {
            return this.unlockingScript;
        }
    };
    FunctionCall.prototype.toHex = function () {
        return this.toScript().toHex();
    };
    FunctionCall.prototype.genLaunchConfig = function (txContext) {
        var _a;
        var pubFunc = this.methodName;
        var name = "Debug ".concat(this.contract.contractName);
        var program = "".concat(this.contract.file);
        var asmArgs = this.contract.asmArgs || {};
        var state = {};
        if (contract_1.AbstractContract.isStateful(this.contract)) {
            Object.assign(state, { opReturnHex: ((_a = this.contract.dataPart) === null || _a === void 0 ? void 0 : _a.toHex()) || '' });
        }
        else if (this.contract.dataPart) {
            Object.assign(state, { opReturn: this.contract.dataPart.toASM() });
        }
        var txCtx = Object.assign({}, this.contract.txContext || {}, txContext || {}, state);
        return (0, launchConfig_1.genLaunchConfigFile)(this.contract.resolver, this.contract.ctorArgs(), this.args, pubFunc, name, program, txCtx, asmArgs);
    };
    FunctionCall.prototype.verify = function (txContext) {
        var result = this.contract.run_verify(this.unlockingScript, txContext);
        if (!result.success) {
            var debugUrl = this.genLaunchConfig(txContext);
            if (debugUrl) {
                result.error = result.error + "\t[Launch Debugger](".concat(debugUrl.replace(/file:/i, 'scryptlaunch:'), ")\n");
            }
        }
        return result;
    };
    return FunctionCall;
}());
exports.FunctionCall = FunctionCall;
var ABICoder = /** @class */ (function () {
    function ABICoder(abi, resolver, contractName) {
        this.abi = abi;
        this.resolver = resolver;
        this.contractName = contractName;
    }
    ABICoder.prototype.encodeConstructorCall = function (contract, hexTemplate) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var constructorABI = this.abi.filter(function (entity) { return entity.type === compilerWrapper_1.ABIEntityType.CONSTRUCTOR; })[0];
        var cParams = (constructorABI === null || constructorABI === void 0 ? void 0 : constructorABI.params) || [];
        var args_ = contract.checkArgs.apply(contract, __spreadArray(['constructor', cParams], __read(args), false));
        // handle array type
        var flatteredArgs = cParams.flatMap(function (p, index) {
            var a = Object.assign(__assign({}, p), {
                value: args_[index]
            });
            return (0, typeCheck_1.flatternArg)(a, _this.resolver, { state: false, ignoreValue: false });
        });
        flatteredArgs.forEach(function (arg) {
            if (!hexTemplate.includes("<".concat(arg.name, ">"))) {
                throw new Error("abi constructor params mismatch with args provided: missing ".concat(arg.name, " in ASM tempalte"));
            }
            contract.hexTemplateArgs.set("<".concat(arg.name, ">"), (0, serializer_1.toScriptHex)(arg.value, arg.type));
        });
        var hasCodePartTemplate = hexTemplate.match(/<__codePart__>/g) ? true : false;
        if (hasCodePartTemplate) {
            contract.hexTemplateArgs.set('<__codePart__>', '00');
        }
        // Check if inline ASM var values are expected to be set.
        var templateMatches = hexTemplate.match(/<.*?>/g);
        var templateCount = templateMatches ? templateMatches.length : 0;
        contract.hasInlineASMVars = hasCodePartTemplate ?
            templateCount > contract.hexTemplateArgs.size + 1 :
            templateCount > contract.hexTemplateArgs.size;
        contract.statePropsArgs = stateful_1.default.buildDefaultStateArgs(contract);
        var lockingScript = (0, utils_1.buildContractCode)(contract.hexTemplateArgs, contract.hexTemplateInlineASM, hexTemplate);
        return new FunctionCall('constructor', {
            contract: contract,
            lockingScript: lockingScript,
            args: cParams.map(function (param, index) { return ({
                name: param.name,
                type: param.type,
                value: args_[index]
            }); })
        });
    };
    ABICoder.prototype.encodeConstructorCallFromRawHex = function (contract, hexTemplate, raw) {
        var script = utils_1.bsv.Script.fromHex(raw);
        var constructorABI = this.abi.filter(function (entity) { return entity.type === compilerWrapper_1.ABIEntityType.CONSTRUCTOR; })[0];
        var cParams = (constructorABI === null || constructorABI === void 0 ? void 0 : constructorABI.params) || [];
        var offset = 0;
        var dataPartInHex = undefined;
        var codePartEndIndex = -1;
        var err = new Error("the raw script cannot match the ASM template of contract ".concat(contract.contractName));
        function checkOp(chunk) {
            var op = hexTemplate.substring(offset, offset + 2);
            if (parseInt(op, 16) != chunk.opcodenum) {
                throw err;
            }
            offset = offset + 2;
        }
        function checkPushByteLength(chunk) {
            var op = hexTemplate.substring(offset, offset + 2);
            if (parseInt(op, 16) != chunk.opcodenum) {
                throw err;
            }
            offset = offset + 2;
            var data = hexTemplate.substring(offset, offset + chunk.len * 2);
            if (chunk.buf.toString('hex') != data) {
                throw err;
            }
            offset = offset + chunk.len * 2;
        }
        function checkPushData1(chunk) {
            var op = hexTemplate.substring(offset, offset + 2);
            if (parseInt(op, 16) != chunk.opcodenum) {
                throw err;
            }
            offset = offset + 2;
            var next1Byte = hexTemplate.substring(offset, offset + 2);
            if (parseInt(next1Byte, 16) != chunk.len) {
                throw err;
            }
            offset = offset + 2;
            var data = hexTemplate.substring(offset, offset + chunk.len * 2);
            if (chunk.buf.toString('hex') != data) {
                throw err;
            }
            offset = offset + chunk.len * 2;
        }
        function checkPushData2(chunk) {
            var op = hexTemplate.substring(offset, offset + 2);
            if (parseInt(op, 16) != chunk.opcodenum) {
                throw err;
            }
            offset = offset + 2;
            var next2Byte = hexTemplate.substring(offset, offset + 4);
            if ((0, builtins_1.bin2num)(next2Byte) != BigInt(chunk.len)) {
                throw err;
            }
            offset = offset + 4;
            var data = hexTemplate.substring(offset, offset + chunk.len * 2);
            if (chunk.buf.toString('hex') != data) {
                throw err;
            }
            offset = offset + chunk.len * 2;
        }
        function checkPushData4(chunk) {
            var op = hexTemplate.substring(offset, offset + 2);
            if (parseInt(op, 16) != chunk.opcodenum) {
                throw err;
            }
            offset = offset + 2;
            var next4Byte = hexTemplate.substring(offset, offset + 8);
            if ((0, builtins_1.bin2num)(next4Byte) != BigInt(chunk.len)) {
                throw err;
            }
            offset = offset + 8;
            var data = hexTemplate.substring(offset, offset + chunk.len * 2);
            if (chunk.buf.toString('hex') != data) {
                throw err;
            }
            offset = offset + chunk.len * 2;
        }
        function findTemplateVariable() {
            if (hexTemplate.charAt(offset) == '<') {
                var start = offset;
                var found = false;
                while (!found && offset < hexTemplate.length) {
                    offset++;
                    if (hexTemplate.charAt(offset) == '>') {
                        offset++;
                        found = true;
                    }
                }
                if (!found) {
                    throw new Error('cannot found break >');
                }
                return hexTemplate.substring(start, offset);
            }
        }
        function saveTemplateVariableValue(name, chunk) {
            var bw = new utils_1.bsv.encoding.BufferWriter();
            bw.writeUInt8(chunk.opcodenum);
            if (chunk.buf) {
                if (chunk.opcodenum < utils_1.bsv.Opcode.OP_PUSHDATA1) {
                    bw.write(chunk.buf);
                }
                else if (chunk.opcodenum === utils_1.bsv.Opcode.OP_PUSHDATA1) {
                    bw.writeUInt8(chunk.len);
                    bw.write(chunk.buf);
                }
                else if (chunk.opcodenum === utils_1.bsv.Opcode.OP_PUSHDATA2) {
                    bw.writeUInt16LE(chunk.len);
                    bw.write(chunk.buf);
                }
                else if (chunk.opcodenum === utils_1.bsv.Opcode.OP_PUSHDATA4) {
                    bw.writeUInt32LE(chunk.len);
                    bw.write(chunk.buf);
                }
            }
            if (name.startsWith("<".concat(contract.contractName, "."))) { //inline asm
                contract.hexTemplateInlineASM.set(name, bw.toBuffer().toString('hex'));
            }
            else {
                contract.hexTemplateArgs.set(name, bw.toBuffer().toString('hex'));
            }
        }
        for (var index = 0; index < script.chunks.length; index++) {
            var chunk = script.chunks[index];
            var breakfor = false;
            switch (true) {
                case (chunk.opcodenum === 106):
                    {
                        if (offset >= hexTemplate.length) {
                            var b = utils_1.bsv.Script.fromChunks(script.chunks.slice(index + 1));
                            dataPartInHex = b.toHex();
                            codePartEndIndex = index;
                            breakfor = true;
                        }
                        else {
                            checkOp(chunk);
                        }
                        break;
                    }
                case (chunk.opcodenum === 0): {
                    var variable = findTemplateVariable();
                    if (variable) {
                        saveTemplateVariableValue(variable, chunk);
                    }
                    else {
                        checkOp(chunk);
                    }
                    break;
                }
                case (chunk.opcodenum >= 1 && chunk.opcodenum <= 75):
                    {
                        var variable = findTemplateVariable();
                        if (variable) {
                            saveTemplateVariableValue(variable, chunk);
                        }
                        else {
                            checkPushByteLength(chunk);
                        }
                        break;
                    }
                case (chunk.opcodenum >= 79 && chunk.opcodenum <= 96):
                    {
                        var variable = findTemplateVariable();
                        if (variable) {
                            saveTemplateVariableValue(variable, chunk);
                        }
                        else {
                            checkOp(chunk);
                        }
                        break;
                    }
                case (chunk.opcodenum === 76):
                    {
                        var variable = findTemplateVariable();
                        if (variable) {
                            saveTemplateVariableValue(variable, chunk);
                        }
                        else {
                            checkPushData1(chunk);
                        }
                        break;
                    }
                case (chunk.opcodenum === 77):
                    {
                        var variable = findTemplateVariable();
                        if (variable) {
                            saveTemplateVariableValue(variable, chunk);
                        }
                        else {
                            checkPushData2(chunk);
                        }
                        break;
                    }
                case (chunk.opcodenum === 78):
                    {
                        var variable = findTemplateVariable();
                        if (variable) {
                            saveTemplateVariableValue(variable, chunk);
                        }
                        else {
                            checkPushData4(chunk);
                        }
                        break;
                    }
                default:
                    {
                        checkOp(chunk);
                    }
            }
            if (breakfor) {
                break;
            }
        }
        var ctorArgs = cParams.map(function (param) { return (0, deserializer_1.deserializeArgfromHex)(contract.resolver, Object.assign(param, {
            value: false // fake value
        }), contract.hexTemplateArgs, { state: false }); });
        if (contract_1.AbstractContract.isStateful(contract) && dataPartInHex) {
            var scriptHex = dataPartInHex;
            var metaScript = dataPartInHex.substr(scriptHex.length - 10, 10);
            var version = (0, builtins_1.bin2num)(metaScript.substr(metaScript.length - 2, 2));
            switch (version) {
                case (0, scryptTypes_1.Int)(0):
                    {
                        var _a = __read(stateful_1.default.parseStateHex(contract, scriptHex), 2), isGenesis = _a[0], args = _a[1];
                        contract.statePropsArgs = args;
                        contract.isGenesis = isGenesis;
                    }
                    break;
            }
        }
        else if (dataPartInHex) {
            contract.setDataPartInHex(dataPartInHex);
        }
        return new FunctionCall('constructor', {
            contract: contract,
            lockingScript: codePartEndIndex > -1 ? utils_1.bsv.Script.fromChunks(script.chunks.slice(0, codePartEndIndex)) : script,
            args: ctorArgs
        });
    };
    ABICoder.prototype.encodePubFunctionCall = function (contract, name, args) {
        var e_1, _a;
        var _this = this;
        var _loop_1 = function (entity) {
            if (entity.name === name) {
                var args_1 = contract.checkArgs.apply(contract, __spreadArray([name, entity.params], __read(args), false));
                var flatteredArgs = entity.params.flatMap(function (p, index) {
                    var a = Object.assign(__assign({}, p), {
                        value: args_1[index]
                    });
                    return (0, typeCheck_1.flatternArg)(a, _this.resolver, { state: false, ignoreValue: false });
                });
                var hex = flatteredArgs.map(function (a) { return (0, serializer_1.toScriptHex)(a.value, a.type); }).join('');
                if (this_1.abi.length > 2 && entity.index !== undefined) {
                    // selector when there are multiple public functions
                    var pubFuncIndex = entity.index;
                    hex += "".concat(utils_1.bsv.Script.fromASM((0, utils_1.int2Asm)(pubFuncIndex.toString())).toHex());
                }
                return { value: new FunctionCall(name, {
                        contract: contract,
                        unlockingScript: utils_1.bsv.Script.fromHex(hex), args: entity.params.map(function (param, index) { return ({
                            name: param.name,
                            type: param.type,
                            value: args_1[index]
                        }); })
                    }) };
            }
        };
        var this_1 = this;
        try {
            for (var _b = __values(this.abi), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entity = _c.value;
                var state_1 = _loop_1(entity);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new Error("no public function named '".concat(name, "' found in contract '").concat(contract.contractName, "'"));
    };
    /**
       * build a FunctionCall by function name and unlocking script in hex.
       * @param contract
       * @param name name of public function
       * @param hex hex of unlocking script
       * @returns a FunctionCall which contains the function parameters that have been deserialized
       */
    ABICoder.prototype.encodePubFunctionCallFromHex = function (contract, hex) {
        var callData = this.parseCallData(hex);
        return new FunctionCall(callData.methodName, { contract: contract, unlockingScript: callData.unlockingScript, args: callData.args });
    };
    /**
       * build a CallData by unlocking script in hex.
       * @param hex hex of unlocking script
       * @returns a CallData which contains the function parameters that have been deserialized
       */
    ABICoder.prototype.parseCallData = function (hex) {
        var _this = this;
        var unlockingScript = utils_1.bsv.Script.fromHex(hex);
        var usASM = unlockingScript.toASM();
        var pubFunAbis = this.abi.filter(function (entity) { return entity.type === 'function'; });
        var pubFunCount = pubFunAbis.length;
        var entity = undefined;
        if (pubFunCount === 1) {
            entity = pubFunAbis[0];
        }
        else {
            var pubFuncIndexASM = usASM.slice(usASM.lastIndexOf(' ') + 1);
            var pubFuncIndex_1 = (0, utils_1.asm2int)(pubFuncIndexASM);
            entity = this.abi.find(function (entity) { return entity.index === pubFuncIndex_1; });
        }
        if (!entity) {
            throw new Error("the raw unlocking script cannot match the contract ".concat(this.constructor.name));
        }
        var cParams = entity.params || [];
        var dummyArgs = cParams.map(function (p) {
            var dummyArg = Object.assign({}, p, { value: false });
            return (0, typeCheck_1.flatternArg)(dummyArg, _this.resolver, { state: true, ignoreValue: true });
        }).flat(Infinity);
        var fArgsLen = dummyArgs.length;
        if (this.abi.length > 2 && entity.index !== undefined) {
            fArgsLen += 1;
        }
        var asmOpcodes = usASM.split(' ');
        if (fArgsLen != asmOpcodes.length) {
            throw new Error("the raw unlockingScript cannot match the arguments of public function ".concat(entity.name, " of contract ").concat(this.contractName));
        }
        var hexTemplateArgs = new Map();
        dummyArgs.forEach(function (farg, index) {
            hexTemplateArgs.set("<".concat(farg.name, ">"), utils_1.bsv.Script.fromASM(asmOpcodes[index]).toHex());
        });
        var args = cParams.map(function (param) { return (0, deserializer_1.deserializeArgfromHex)(_this.resolver, Object.assign(param, {
            value: false //fake value
        }), hexTemplateArgs, { state: false }); });
        return {
            methodName: entity.name,
            args: args,
            unlockingScript: unlockingScript
        };
    };
    return ABICoder;
}());
exports.ABICoder = ABICoder;
//# sourceMappingURL=abi.js.map