"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNOPScript = exports.md5 = exports.findSrcInfoV1 = exports.findSrcInfoV2 = exports.JSONStringify = exports.JSONParserSync = exports.JSONParser = exports.structSign = exports.librarySign = exports.parseAbiFromUnlockingScript = exports.buildContractCode = exports.stripAnsi = exports.ansiRegex = exports.resolveConstValue = exports.newCall = exports.compileContractAsync = exports.compileContract = exports.isEmpty = exports.readFileByLine = exports.subscript = exports.toGenericType = exports.findStructByType = exports.getNameByType = exports.isArrayType = exports.findStructByName = exports.uri2path = exports.path2uri = exports.isNode = exports.getLowSPreimage = exports.hashIsPositiveNumber = exports.getPreimage = exports.signTx = exports.hexStringToBytes = exports.bytesToHexString = exports.bytes2Literal = exports.utf82Hex = exports.toHex = exports.uint82hex = exports.asm2int = exports.int2Asm = exports.DEFAULT_SIGHASH_TYPE = exports.DEFAULT_FLAGS = exports.bsv = void 0;
var json_ext_1 = require("@discoveryjs/json-ext");
var bsv = require("bsv");
exports.bsv = bsv;
var crypto = require("crypto");
var fs = require("fs");
var path_1 = require("path");
var sourcemap_codec_1 = require("@jridgewell/sourcemap-codec");
var url_1 = require("url");
var compilerWrapper_1 = require("./compilerWrapper");
var internal_1 = require("./internal");
var typeCheck_1 = require("./typeCheck");
var BN = bsv.crypto.BN;
var Interp = bsv.Script.Interpreter;
exports.DEFAULT_FLAGS = 
//Interp.SCRIPT_VERIFY_P2SH | Interp.SCRIPT_VERIFY_CLEANSTACK | // no longer applies now p2sh is deprecated: cleanstack only applies to p2sh
Interp.SCRIPT_ENABLE_MAGNETIC_OPCODES | Interp.SCRIPT_ENABLE_MONOLITH_OPCODES | // TODO: to be removed after upgrade to bsv 2.0
    Interp.SCRIPT_VERIFY_STRICTENC |
    Interp.SCRIPT_ENABLE_SIGHASH_FORKID | Interp.SCRIPT_VERIFY_LOW_S | Interp.SCRIPT_VERIFY_NULLFAIL |
    Interp.SCRIPT_VERIFY_DERSIG |
    Interp.SCRIPT_VERIFY_MINIMALDATA | Interp.SCRIPT_VERIFY_NULLDUMMY |
    Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |
    Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY | Interp.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY | Interp.SCRIPT_VERIFY_CLEANSTACK;
exports.DEFAULT_SIGHASH_TYPE = bsv.crypto.Signature.SIGHASH_ALL | bsv.crypto.Signature.SIGHASH_FORKID;
/**
 * decimal or hex int to little-endian signed magnitude
 */
function int2Asm(str) {
    if (/^(-?\d+)$/.test(str) || /^0x([0-9a-fA-F]+)$/.test(str)) {
        var number = str.startsWith('0x') ? new BN(str.substring(2), 16) : new BN(str, 10);
        if (number.eqn(-1)) {
            return 'OP_1NEGATE';
        }
        if (number.gten(0) && number.lten(16)) {
            return 'OP_' + number.toString();
        }
        var m = number.toSM({ endian: 'little' });
        return m.toString('hex');
    }
    else {
        throw new Error("invalid str '".concat(str, "' to convert to int"));
    }
}
exports.int2Asm = int2Asm;
/**
 * convert asm string to number or bigint
 */
function asm2int(str) {
    switch (str) {
        case 'OP_1NEGATE':
            return -1;
        case '0':
        case 'OP_0':
        case 'OP_1':
        case 'OP_2':
        case 'OP_3':
        case 'OP_4':
        case 'OP_5':
        case 'OP_6':
        case 'OP_7':
        case 'OP_8':
        case 'OP_9':
        case 'OP_10':
        case 'OP_11':
        case 'OP_12':
        case 'OP_13':
        case 'OP_14':
        case 'OP_15':
        case 'OP_16':
            return parseInt(str.replace('OP_', ''));
        default: {
            var value = (0, internal_1.getValidatedHexString)(str);
            var bn = BN.fromHex(value, {
                endian: 'little'
            });
            if (bn.toNumber() < Number.MAX_SAFE_INTEGER && bn.toNumber() > Number.MIN_SAFE_INTEGER) {
                return bn.toNumber();
            }
            else {
                return bn.toString();
            }
        }
    }
}
exports.asm2int = asm2int;
function uint82hex(val) {
    var hex = val.toString(16);
    if (hex.length % 2 === 1) {
        hex = '0' + hex;
    }
    return hex;
}
exports.uint82hex = uint82hex;
function toHex(x) {
    return x.toString('hex');
}
exports.toHex = toHex;
function utf82Hex(val) {
    var encoder = new TextEncoder();
    var uint8array = encoder.encode(val);
    return toHex(Buffer.from(uint8array));
}
exports.utf82Hex = utf82Hex;
function bytes2Literal(bytearray, type) {
    switch (type) {
        case 'bool':
            return BN.fromBuffer(bytearray, { endian: 'little' }).gt(0) ? 'true' : 'false';
        case 'int':
        case 'PrivKey':
            return BN.fromSM(bytearray, { endian: 'little' }).toString();
        case 'bytes':
            return "b'".concat(bytesToHexString(bytearray), "'");
        default:
            return "b'".concat(bytesToHexString(bytearray), "'");
    }
}
exports.bytes2Literal = bytes2Literal;
function bytesToHexString(bytearray) {
    return bytearray.reduce(function (o, c) { return o += ('0' + (c & 0xFF).toString(16)).slice(-2); }, '');
}
exports.bytesToHexString = bytesToHexString;
function hexStringToBytes(hex) {
    (0, internal_1.getValidatedHexString)(hex);
    return hex.split('')
        .reduce(function (o, c, i) {
        if (i % 2 === 0) {
            o.push(c);
        }
        else {
            o[o.length - 1] += c;
        }
        return o;
    }, new Array())
        .map(function (b) { return parseInt(b, 16); });
}
exports.hexStringToBytes = hexStringToBytes;
function signTx(tx, privateKey, lockingScript, inputAmount, inputIndex, sighashType, flags, hashCache) {
    if (inputIndex === void 0) { inputIndex = 0; }
    if (sighashType === void 0) { sighashType = exports.DEFAULT_SIGHASH_TYPE; }
    if (flags === void 0) { flags = exports.DEFAULT_FLAGS; }
    if (!tx) {
        throw new Error('param tx can not be empty');
    }
    if (!privateKey) {
        throw new Error('param privateKey can not be empty');
    }
    if (!lockingScript) {
        throw new Error('param lockingScript can not be empty');
    }
    if (!inputAmount) {
        throw new Error('param inputAmount can not be empty');
    }
    if (typeof lockingScript === 'string') {
        throw new Error('Breaking change: LockingScript in ASM format is no longer supported, please use the lockingScript object directly');
    }
    return toHex(bsv.Transaction.Sighash.sign(tx, privateKey, sighashType, inputIndex, lockingScript, new bsv.crypto.BN(inputAmount), flags, hashCache).toTxFormat());
}
exports.signTx = signTx;
function getPreimage(tx, lockingScript, inputAmount, inputIndex, sighashType, flags) {
    if (inputIndex === void 0) { inputIndex = 0; }
    if (sighashType === void 0) { sighashType = exports.DEFAULT_SIGHASH_TYPE; }
    if (flags === void 0) { flags = exports.DEFAULT_FLAGS; }
    var preimageBuf = bsv.Transaction.Sighash.sighashPreimage(tx, sighashType, inputIndex, lockingScript, new bsv.crypto.BN(inputAmount), flags);
    return toHex(preimageBuf);
}
exports.getPreimage = getPreimage;
var MSB_THRESHOLD = 0x7e;
function hashIsPositiveNumber(sighash) {
    var highByte = sighash.readUInt8(31);
    return highByte < MSB_THRESHOLD;
}
exports.hashIsPositiveNumber = hashIsPositiveNumber;
function getLowSPreimage(tx, lockingScript, inputAmount, inputIndex, sighashType, flags) {
    if (inputIndex === void 0) { inputIndex = 0; }
    if (sighashType === void 0) { sighashType = exports.DEFAULT_SIGHASH_TYPE; }
    if (flags === void 0) { flags = exports.DEFAULT_FLAGS; }
    for (var i = 0; i < Number.MAX_SAFE_INTEGER; i++) {
        var preimage = getPreimage(tx, lockingScript, inputAmount, inputIndex, sighashType, flags);
        var sighash = bsv.crypto.Hash.sha256sha256(Buffer.from(preimage, 'hex'));
        var msb = sighash.readUInt8();
        if (msb < MSB_THRESHOLD && hashIsPositiveNumber(sighash)) {
            return preimage;
        }
        tx.inputs[inputIndex].sequenceNumber--;
    }
}
exports.getLowSPreimage = getLowSPreimage;
function isNode() {
    return typeof window === 'undefined' && typeof process === 'object';
}
exports.isNode = isNode;
function path2uri(path) {
    if (isNode()) {
        return (0, url_1.pathToFileURL)(path).toString();
    }
    else {
        return path;
    }
}
exports.path2uri = path2uri;
function uri2path(uri) {
    if (isNode()) {
        return (0, url_1.fileURLToPath)(uri);
    }
    else {
        return uri;
    }
}
exports.uri2path = uri2path;
function findStructByName(name, s) {
    return s.find(function (s) {
        return s.name == name;
    });
}
exports.findStructByName = findStructByName;
// test Token[3], int[3], st.b.c[3]
function isArrayType(type) {
    return /^(.+)(\[[\w.]+\])+$/.test(type);
}
exports.isArrayType = isArrayType;
function getNameByType(type) {
    if (isArrayType(type)) {
        /* eslint-disable @typescript-eslint/no-unused-vars */
        var _a = __read((0, typeCheck_1.arrayTypeAndSizeStr)(type), 2), elemType = _a[0], _ = _a[1];
        return getNameByType(elemType);
    }
    if ((0, typeCheck_1.isGenericType)(type)) {
        /* eslint-disable @typescript-eslint/no-unused-vars */
        var _b = __read((0, typeCheck_1.parseGenericType)(type), 2), tn = _b[0], _ = _b[1];
        return getNameByType(tn);
    }
    return type;
}
exports.getNameByType = getNameByType;
function findStructByType(type, s) {
    var name = getNameByType(type);
    if (name) {
        return findStructByName(name, s);
    }
    return undefined;
}
exports.findStructByType = findStructByType;
function toGenericType(name, genericTypes) {
    return "".concat(name, "<").concat(genericTypes.join(','), ">");
}
exports.toGenericType = toGenericType;
function subscript(index, arraySizes) {
    if (arraySizes.length == 1) {
        return "[".concat(index, "]");
    }
    else {
        var subArraySizes = arraySizes.slice(1);
        var offset = subArraySizes.reduce(function (acc, val) { return acc * val; }, 1);
        return "[".concat(Math.floor(index / offset), "]").concat(subscript(index % offset, subArraySizes));
    }
}
exports.subscript = subscript;
function readFileByLine(path, index) {
    var result = '';
    fs.readFileSync(path, 'utf8').split(/\r?\n/).every(function (line, i) {
        if (i === (index - 1)) {
            result = line;
            return false;
        }
        return true;
    });
    return result;
}
exports.readFileByLine = readFileByLine;
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
exports.isEmpty = isEmpty;
function compileContract(file, options) {
    options = Object.assign({
        out: (0, path_1.join)(__dirname, '../out'),
        sourceMap: false,
        artifact: false,
    }, options);
    if (!fs.existsSync(file)) {
        throw ("file ".concat(file, " not exists!"));
    }
    if (!fs.existsSync(options.out)) {
        fs.mkdirSync(options.out);
    }
    var result = (0, internal_1.compile)({ path: file }, {
        artifact: options.artifact, outputDir: options.out,
        sourceMap: options.sourceMap,
        cmdPrefix: (0, internal_1.findCompiler)()
    });
    return result;
}
exports.compileContract = compileContract;
function compileContractAsync(file, options) {
    options = Object.assign({
        out: (0, path_1.join)(__dirname, '..', 'out'),
        sourceMap: false,
        artifact: false,
    }, options);
    if (!fs.existsSync(file)) {
        throw ("file ".concat(file, " not exists!"));
    }
    if (!fs.existsSync(options.out)) {
        fs.mkdirSync(options.out);
    }
    return (0, compilerWrapper_1.compileAsync)({ path: file }, {
        artifact: options.artifact, outputDir: options.out,
        sourceMap: options.sourceMap,
        hex: true,
        cmdPrefix: (0, internal_1.findCompiler)()
    });
}
exports.compileContractAsync = compileContractAsync;
function newCall(Cls, args) {
    return new (Function.prototype.bind.apply(Cls, [null].concat(args)));
}
exports.newCall = newCall;
function resolveConstValue(node) {
    var value = undefined;
    if (node.expr.nodeType === 'IntLiteral') {
        value = node.expr.value.toString(10);
    }
    else if (node.expr.nodeType === 'BoolLiteral') {
        value = node.expr.value;
    }
    if (node.expr.nodeType === 'BytesLiteral') {
        value = "b'".concat(node.expr.value.map(function (a) { return uint82hex(a); }).join(''), "'");
    }
    if (node.expr.nodeType === 'FunctionCall') {
        if ([internal_1.ScryptType.PUBKEY, internal_1.ScryptType.RIPEMD160, internal_1.ScryptType.SIG, internal_1.ScryptType.SIGHASHTYPE, internal_1.ScryptType.OPCODETYPE, internal_1.ScryptType.SIGHASHPREIMAGE, internal_1.ScryptType.SHA1, internal_1.ScryptType.SHA256].includes(node.expr.name)) {
            value = "b'".concat(node.expr.params[0].value.map(function (a) { return uint82hex(a); }).join(''), "'");
        }
        else if (node.expr.name === internal_1.ScryptType.PRIVKEY) {
            value = node.expr.params[0].value.toString(10);
        }
    }
    return value;
}
exports.resolveConstValue = resolveConstValue;
function ansiRegex(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.onlyFirst, onlyFirst = _c === void 0 ? false : _c;
    var pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
}
exports.ansiRegex = ansiRegex;
function stripAnsi(string) {
    if (typeof string !== 'string') {
        throw new TypeError("Expected a `string`, got `".concat(typeof string, "`"));
    }
    return string.replace(ansiRegex(), '');
}
exports.stripAnsi = stripAnsi;
function escapeRegExp(stringToGoIntoTheRegex) {
    return stringToGoIntoTheRegex.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function buildContractCode(hexTemplateArgs, hexTemplateInlineASM, hexTemplate) {
    var e_1, _a, e_2, _b;
    var lsHex = hexTemplate;
    try {
        for (var _c = __values(hexTemplateArgs.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var entry = _d.value;
            var name_1 = entry[0];
            var value = entry[1];
            lsHex = lsHex.replace(name_1, value);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _e = __values(hexTemplateInlineASM.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var entry = _f.value;
            var name_2 = entry[0];
            var value = entry[1];
            lsHex = lsHex.replace(new RegExp("".concat(escapeRegExp(name_2)), 'g'), value);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return bsv.Script.fromHex(lsHex);
}
exports.buildContractCode = buildContractCode;
/**
 * Parse out which public function is called through unlocking script
 * @param contract
 * @param hex hex of unlocking script
 * @returns return ABIEntity of the public function which is call by the unlocking script
 */
function parseAbiFromUnlockingScript(contract, hex) {
    var abis = Object.getPrototypeOf(contract).constructor.abi;
    var pubFunAbis = abis.filter(function (entity) { return entity.type === 'function'; });
    var pubFunCount = pubFunAbis.length;
    if (pubFunCount === 1) {
        return pubFunAbis[0];
    }
    var script = bsv.Script.fromHex(hex);
    var usASM = script.toASM();
    var pubFuncIndexASM = usASM.substr(usASM.lastIndexOf(' ') + 1);
    var pubFuncIndex = asm2int(pubFuncIndexASM);
    var entity = abis.find(function (entity) { return entity.index === pubFuncIndex; });
    if (!entity) {
        throw new Error("the raw unlocking script cannot match the contract ".concat(contract.contractName));
    }
    return entity;
}
exports.parseAbiFromUnlockingScript = parseAbiFromUnlockingScript;
function librarySign(genericEntity) {
    return "[".concat(genericEntity.params.map(function (p) { return p.type; }).join(','), "]");
}
exports.librarySign = librarySign;
function structSign(structEntity) {
    return "".concat(JSON.stringify(structEntity.params.reduce(function (p, v) {
        var _a;
        return Object.assign(p, (_a = {},
            _a[v.name] = v.type,
            _a));
    }, {}), null, 4));
}
exports.structSign = structSign;
function JSONParser(file) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    (0, json_ext_1.parseChunked)(fs.createReadStream(file))
                        .then(function (data) {
                        resolve(data);
                    })
                        .catch(function (e) {
                        reject(e);
                    });
                })];
        });
    });
}
exports.JSONParser = JSONParser;
function JSONParserSync(file) {
    return JSON.parse(fs.readFileSync(file, 'utf8'));
}
exports.JSONParserSync = JSONParserSync;
function JSONStringify(file, data) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    (0, json_ext_1.stringifyStream)(data)
                        .pipe(fs.createWriteStream(file))
                        .on('finish', function () {
                        resolve(true);
                    })
                        .on('error', function (e) {
                        reject(e);
                    });
                })];
        });
    });
}
exports.JSONStringify = JSONStringify;
function findSrcInfoV2(pc, sourceMap) {
    var decoded = (0, sourcemap_codec_1.decode)(sourceMap['mappings']);
    for (var index = 0; index < decoded[0].length; index++) {
        var element = decoded[0][index];
        if (element[0] <= pc) {
            continue;
        }
        return decoded[0][index - 1];
    }
    return decoded[0][decoded[0].length - 1];
}
exports.findSrcInfoV2 = findSrcInfoV2;
/**
 * @deprecated use findSrcInfoV2
 * @param opcodes OpCode[] from sourceMap
 */
function findSrcInfoV1(opcodes, opcodesIndex) {
    while (--opcodesIndex > 0) {
        if (opcodes[opcodesIndex].pos && opcodes[opcodesIndex].pos.file !== 'std' && opcodes[opcodesIndex].pos.line > 0) {
            return opcodes[opcodesIndex];
        }
    }
}
exports.findSrcInfoV1 = findSrcInfoV1;
function md5(s) {
    var md5 = crypto.createHash('md5');
    return md5.update(s).digest('hex');
}
exports.md5 = md5;
function checkNOPScript(nopScript) {
    bsv.Script.Interpreter.MAX_SCRIPT_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
    bsv.Script.Interpreter.MAXIMUM_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
    var bsi = new bsv.Script.Interpreter();
    var tx = new bsv.Transaction().from({
        txId: 'a477af6b2667c29670467e4e0728b685ee07b240235771862318e29ddbe58458',
        outputIndex: 0,
        script: '',
        satoshis: 1
    });
    var result = bsi.verify(new bsv.Script(""), nopScript, tx, 0, exports.DEFAULT_FLAGS, new bsv.crypto.BN(1));
    if (result || bsi.errstr !== "SCRIPT_ERR_EVAL_FALSE_NO_RESULT") {
        throw new Error("NopScript should be a script that does not affect the Bitcoin virtual machine stack.");
    }
}
exports.checkNOPScript = checkNOPScript;
//# sourceMappingURL=utils.js.map