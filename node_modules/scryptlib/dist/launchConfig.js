"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readLaunchJson = exports.parseLiteral = exports.stringToBytes = exports.toJSON = exports.genLaunchConfigFile = void 0;
var internal_1 = require("./internal");
var utils_1 = require("./utils");
var fs = require("fs");
var os_1 = require("os");
var path_1 = require("path");
function genLaunchConfigFile(resolver, constructorArgs, pubFuncArgs, pubFunc, name, program, txContext, asmArgs) {
    // some artifact without sourceMap will not have file property.
    if (!program) {
        return '';
    }
    var debugConfig = {
        type: 'scrypt',
        request: 'launch',
        internalConsoleOptions: 'openOnSessionStart',
        name: name,
        program: program,
        constructorArgs: constructorArgs.map(function (a) { return toJSON(a, resolver); }),
        pubFunc: pubFunc,
        pubFuncArgs: pubFuncArgs.map(function (a) { return toJSON(a, resolver); })
    };
    var debugTxContext = {};
    if (!(0, utils_1.isEmpty)(txContext)) {
        var inputIndex = txContext.inputIndex || 0;
        if (txContext.tx) {
            var inputSatoshis = txContext.inputSatoshis;
            Object.assign(debugTxContext, { hex: txContext.tx.toString(), inputIndex: inputIndex, inputSatoshis: inputSatoshis });
        }
        if (txContext.opReturn) {
            Object.assign(debugTxContext, { opReturn: txContext.opReturn });
        }
        else if (txContext.opReturnHex) {
            Object.assign(debugTxContext, { opReturnHex: txContext.opReturnHex });
        }
    }
    if (!(0, utils_1.isEmpty)(asmArgs)) {
        Object.assign(debugConfig, { asmArgs: asmArgs });
    }
    if (!(0, utils_1.isEmpty)(debugTxContext)) {
        Object.assign(debugConfig, { txContext: debugTxContext });
    }
    var launch = {
        version: '0.2.0',
        configurations: [debugConfig]
    };
    var jsonstr = JSON.stringify(launch, function (key, value) { return (typeof value === 'bigint'
        ? value.toString()
        : value // return everything else unchanged
    ); }, 2);
    if ((0, utils_1.isNode)()) {
        var filename = "".concat(name, "-launch.json");
        var file = (0, path_1.join)(fs.mkdtempSync("".concat((0, os_1.tmpdir)()).concat(path_1.sep, "sCrypt.")), filename);
        fs.writeFileSync(file, jsonstr);
        return (0, utils_1.path2uri)(file);
    }
    else {
        console.error("".concat(pubFunc, "() call fail, see launch.json"), jsonstr);
    }
}
exports.genLaunchConfigFile = genLaunchConfigFile;
function toJSON(arg, resolver) {
    var typeInfo = resolver(arg.type);
    if ((0, utils_1.isArrayType)(typeInfo.finalType)) {
        var v = arg.value;
        /* eslint-disable @typescript-eslint/no-unused-vars */
        var _a = __read((0, internal_1.arrayTypeAndSize)(typeInfo.finalType), 2), _ = _a[0], arraySizes_1 = _a[1];
        var subType_1 = (0, internal_1.subArrayType)(typeInfo.finalType);
        return v.map(function (val, i) { return toJSON({
            name: "".concat(arg.name).concat((0, internal_1.subscript)(i, arraySizes_1)),
            type: subType_1,
            value: val
        }, resolver); });
    }
    else if (typeInfo.symbolType === internal_1.SymbolType.Library) {
        var l_1 = [];
        var entity = (0, internal_1.deduceGenericLibrary)(arg, typeInfo.info, resolver);
        if (entity instanceof Error) {
            throw entity;
        }
        entity.params.forEach(function (p, i) {
            l_1.push(toJSON({
                name: p.name,
                type: p.type,
                value: arg.value[i]
            }, resolver));
        });
        return l_1;
    }
    else if (typeInfo.symbolType === internal_1.SymbolType.Struct) {
        var copy_1 = {};
        var entity = (0, internal_1.deduceGenericStruct)(arg, typeInfo.info, resolver);
        if (entity instanceof Error) {
            throw entity;
        }
        entity.params.forEach(function (p) {
            var _a;
            Object.assign(copy_1, (_a = {},
                _a[p.name] = toJSON({
                    name: p.name,
                    type: p.type,
                    value: arg.value[p.name]
                }, resolver),
                _a));
        });
        return copy_1;
    }
    else if (typeInfo.symbolType === internal_1.SymbolType.ScryptType) {
        switch (typeInfo.finalType) {
            case internal_1.ScryptType.BOOL:
                return arg.value;
            case internal_1.ScryptType.INT: {
                if (arg.value >= BigInt(Number.MIN_SAFE_INTEGER) && arg.value <= BigInt(Number.MAX_SAFE_INTEGER)) {
                    return Number(arg.value);
                }
                else {
                    return arg.value.toString();
                }
            }
            case internal_1.ScryptType.BYTES: {
                return "b'".concat(arg.value.toString(), "'");
            }
            case internal_1.ScryptType.PRIVKEY: {
                return "PrivKey(".concat(arg.value.toString(), ")");
            }
            case internal_1.ScryptType.SIG:
            case internal_1.ScryptType.RIPEMD160:
            case internal_1.ScryptType.SHA1:
            case internal_1.ScryptType.SHA256:
            case internal_1.ScryptType.SIGHASHPREIMAGE:
            case internal_1.ScryptType.OPCODETYPE:
            case internal_1.ScryptType.SIGHASHTYPE:
            case internal_1.ScryptType.PUBKEY: {
                return "".concat(typeInfo.finalType, "(b'").concat(arg.value.toString(), "')");
            }
        }
    }
}
exports.toJSON = toJSON;
function stringToBytes(str) {
    var encoder = new TextEncoder();
    var uint8array = encoder.encode(str);
    return (0, internal_1.getValidatedHexString)(Buffer.from(uint8array).toString('hex'));
}
exports.stringToBytes = stringToBytes;
function parseLiteral(l, supportInt) {
    if (supportInt === void 0) { supportInt = false; }
    // bool
    if (l === 'false') {
        return [false, internal_1.ScryptType.BOOL];
    }
    if (l === 'true') {
        return [true, internal_1.ScryptType.BOOL];
    }
    if (supportInt) {
        // hex int
        var m_1 = /^(0x[0-9a-fA-F]+)$/.exec(l);
        if (m_1) {
            return [BigInt(m_1[1]), internal_1.ScryptType.INT];
        }
        // decimal int
        m_1 = /^(-?\d+)$/.exec(l);
        if (m_1) {
            return [BigInt(m_1[1]), internal_1.ScryptType.INT];
        }
    }
    else {
        var m_2 = /^([\da-fA-F]*)$/.exec(l);
        if (m_2) {
            return [(0, internal_1.Bytes)(l), internal_1.ScryptType.BYTES];
        }
    }
    // bytes
    // note: special handling of empty bytes b''
    var m = /^b'([\da-fA-F]*)'$/.exec(l);
    if (m) {
        return [(0, internal_1.Bytes)(m[1]), internal_1.ScryptType.BYTES];
    }
    // String
    m = /^"([\s\S]*)"$/.exec(l);
    if (m) {
        return [stringToBytes(m[1]), internal_1.ScryptType.BYTES];
    }
    // PrivKey
    // 1) decimal int
    m = /^PrivKey\((-?\d+)\)$/.exec(l);
    if (m) {
        return [BigInt(m[1]), internal_1.ScryptType.PRIVKEY];
    }
    // 2) hex int
    m = /^PrivKey\((0x[0-9a-fA-F]+)\)$/.exec(l);
    if (m) {
        return [BigInt(m[1]), internal_1.ScryptType.PRIVKEY];
    }
    // PubKey
    m = /^PubKey\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.PUBKEY];
    }
    // Sig
    m = /^Sig\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.SIG];
    }
    // Ripemd160
    m = /^Ripemd160\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.RIPEMD160];
    }
    // Sha1
    m = /^Sha1\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.SHA1];
    }
    // Sha256
    m = /^Sha256\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.SHA256];
    }
    // SigHashType
    m = /^SigHashType\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.SIGHASHTYPE];
    }
    // SigHashPreimage
    m = /^SigHashPreimage\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.SIGHASHPREIMAGE];
    }
    // OpCodeType
    m = /^OpCodeType\(b'([\da-fA-F]+)'\)$/.exec(l);
    if (m) {
        var value = (0, internal_1.getValidatedHexString)(m[1]);
        return [(0, internal_1.Bytes)(value), internal_1.ScryptType.OPCODETYPE];
    }
    throw new Error("<".concat(l, "> cannot be cast to ASM format, only sCrypt native types supported"));
}
exports.parseLiteral = parseLiteral;
var LINKPATTERN = /(\[((!\[[^\]]*?\]\(\s*)([^\s()]+?)\s*\)\]|(?:\\\]|[^\]])*\])\(\s*)(([^\s()]|\([^\s()]*?\))+)\s*(".*?")?\)/g;
function readLaunchJson(error) {
    var e_1, _a;
    try {
        for (var _b = __values(error.matchAll(LINKPATTERN)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var match = _c.value;
            if (match[5] && match[5].startsWith('scryptlaunch')) {
                var file = match[5].replace(/scryptlaunch/, 'file');
                return JSON.parse(fs.readFileSync((0, utils_1.uri2path)(file)).toString());
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}
exports.readLaunchJson = readLaunchJson;
//# sourceMappingURL=launchConfig.js.map