/// <reference types="node" />
import { ChildProcess } from 'child_process';
import { Artifact, TypeResolver } from './internal';
export declare const SOURCE_REG: RegExp;
export declare enum CompileErrorType {
    SyntaxError = "SyntaxError",
    SemanticError = "SemanticError",
    InternalError = "InternalError",
    Warning = "Warning"
}
export declare enum BuildType {
    Debug = "debug",
    Release = "release"
}
export interface RelatedInformation {
    filePath: string;
    position: [
        {
            line: number;
            column: number;
        },
        {
            line: number;
            column: number;
        }?
    ];
    message: string;
}
export interface CompileErrorBase {
    type: string;
    filePath: string;
    position: [
        {
            line: number;
            column: number;
        },
        {
            line: number;
            column: number;
        }?
    ];
    message: string;
    relatedInformation: RelatedInformation[];
}
export interface SyntaxError extends CompileErrorBase {
    type: CompileErrorType.SyntaxError;
    unexpected: string;
    expecting: string;
}
export interface SemanticError extends CompileErrorBase {
    type: CompileErrorType.SemanticError;
}
export interface InternalError extends CompileErrorBase {
    type: CompileErrorType.InternalError;
}
export interface Warning extends CompileErrorBase {
    type: CompileErrorType.Warning;
}
export type CompileError = SyntaxError | SemanticError | InternalError | Warning;
export declare class CompileResult {
    errors: CompileError[];
    warnings: Warning[];
    constructor(errors: CompileError[], warnings: Warning[]);
    asm?: OpCode[];
    hex?: string;
    ast?: Record<string, unknown>;
    dependencyAsts?: Record<string, unknown>;
    abi?: Array<ABIEntity>;
    stateProps?: Array<ParamEntity>;
    compilerVersion?: string;
    contract?: string;
    md5?: string;
    structs?: Array<StructEntity>;
    library?: Array<LibraryEntity>;
    contracts?: Array<ContractEntity>;
    alias?: Array<AliasEntity>;
    file?: string;
    buildType?: string;
    autoTypedVars?: AutoTypedVar[];
    statics?: Array<StaticEntity>;
    sources?: Array<string>;
    sourceMap?: Array<string>;
    sourceMapFile?: string;
    dbgFile?: string;
    toArtifact(): Artifact;
}
export declare enum DebugModeTag {
    FuncStart = "F0",
    FuncEnd = "F1",
    LoopStart = "L0"
}
export interface DebugInfo {
    tag: DebugModeTag;
    contract: string;
    func: string;
    context: string;
}
export interface Pos {
    file: string;
    line: number;
    endLine: number;
    column: number;
    endColumn: number;
}
export interface OpCode {
    opcode: string;
    stack?: string[];
    topVars?: string[];
    pos?: Pos;
    debugInfo?: DebugInfo;
}
export interface AutoTypedVar {
    name: string;
    pos: Pos;
    type: string;
}
export interface ABI {
    contract: string;
    abi: Array<ABIEntity>;
}
export declare enum ABIEntityType {
    FUNCTION = "function",
    CONSTRUCTOR = "constructor"
}
export type ParamEntity = {
    name: string;
    type: string;
};
export interface ABIEntity {
    type: string;
    name?: string;
    params: Array<ParamEntity>;
    index?: number;
}
export interface StructEntity {
    name: string;
    params: Array<ParamEntity>;
    genericTypes: Array<string>;
}
export interface LibraryEntity extends StructEntity {
    properties: Array<ParamEntity>;
}
export interface AliasEntity {
    name: string;
    type: string;
}
export type ContractEntity = LibraryEntity;
export interface StaticEntity {
    name: string;
    type: string;
    const: boolean;
    value?: any;
}
export interface CompilingSettings {
    ast?: boolean;
    asm?: boolean;
    hex?: boolean;
    debug?: boolean;
    artifact?: boolean;
    outputDir?: string;
    outputToFiles?: boolean;
    cwd?: string;
    cmdPrefix?: string;
    cmdArgs?: string;
    buildType?: string;
    stdout?: boolean;
    sourceMap?: boolean;
    timeout?: number;
}
export declare function doCompileAsync(source: {
    path: string;
    content?: string;
}, settings: CompilingSettings, callback?: (error: Error | null, result: {
    path: string;
    output: string;
    md5: string;
} | null) => void): ChildProcess;
export declare function compileAsync(source: {
    path: string;
    content?: string;
}, settings: CompilingSettings): Promise<CompileResult>;
export declare function settings2cmd(sourcePath: string, settings: CompilingSettings): string;
export declare function compile(source: {
    path: string;
    content?: string;
}, settings: CompilingSettings): CompileResult;
export declare function handleCompilerOutput(sourcePath: string, settings: CompilingSettings, output: string, md5: string): CompileResult;
export declare function compilerVersion(cwd: string): string | undefined;
export declare function getFullFilePath(relativePath: string, baseDir: string, curFileName: string): string;
export declare function getContractName(astRoot: unknown): string;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param typeResolver a Type Resolver
 * @returns All function ABIs defined by the main contract, including constructors
 */
export declare function getABIDeclaration(astRoot: unknown, typeResolver: TypeResolver): ABI;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined structures of the main contract and dependent contracts
 */
export declare function getStructDeclaration(astRoot: unknown, dependencyAsts: unknown): Array<StructEntity>;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined Library of the main contract and dependent contracts
 */
export declare function getLibraryDeclaration(astRoot: unknown, dependencyAsts: unknown): Array<LibraryEntity>;
export declare function getContractDeclaration(astRoot: unknown, dependencyAsts: unknown): Array<ContractEntity>;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined type aliaes of the main contract and dependent contracts
 */
export declare function getAliasDeclaration(astRoot: unknown, dependencyAsts: unknown): Array<AliasEntity>;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined static const int literal of the main contract and dependent contracts
 */
export declare function getStaticDeclaration(astRoot: unknown, dependencyAsts: unknown): Array<StaticEntity>;
export declare function loadSourceMapfromArtifact(artifact: Artifact): Array<{
    pos: Pos | undefined;
    opcode: string;
}>;
