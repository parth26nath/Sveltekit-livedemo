"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTypeResolver = exports.buildTypeResolverFromArtifact = exports.buildContractClass = exports.AbstractContract = exports.SUPPORTED_MINIMUM_VERSION = exports.CURRENT_CONTRACT_ARTIFACT_VERSION = void 0;
var path_1 = require("path");
var _1 = require(".");
var compilerWrapper_1 = require("./compilerWrapper");
var internal_1 = require("./internal");
var scryptTypes_1 = require("./scryptTypes");
var stateful_1 = require("./stateful");
var typeCheck_1 = require("./typeCheck");
exports.CURRENT_CONTRACT_ARTIFACT_VERSION = 9;
exports.SUPPORTED_MINIMUM_VERSION = 8;
var AbstractContract = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    /* eslint-disable @typescript-eslint/no-unused-vars */
    function AbstractContract() {
        var ctorParams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            ctorParams[_i] = arguments[_i];
        }
        this.calledPubFunctions = [];
        // This will be set to true, if the contract will expect inline ASM variable values to be set.
        this.hasInlineASMVars = false;
        this.hexTemplateInlineASM = new Map();
        this.hexTemplateArgs = new Map();
        this.statePropsArgs = [];
        // If true, the contract will read the state from property, if false, the contract will read the state from preimage
        // A newly constructed contract always has this set to true, and after invocation, always has it set to false
        this.isGenesis = true;
    }
    Object.defineProperty(AbstractContract.prototype, "lockingScript", {
        get: function () {
            var _a;
            if (this.hasInlineASMVars && this.hexTemplateInlineASM.size === 0) {
                throw new Error('Values for inline ASM variables have not yet been set! Cannot get locking script.');
            }
            if (!this.dataPart) {
                return this._wrapNOPScript((_a = this.scriptedConstructor) === null || _a === void 0 ? void 0 : _a.lockingScript);
            }
            // append dataPart script to codePart if there is dataPart
            return this.codePart.add(this.dataPart);
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.prototype._wrapNOPScript = function (lockingScript) {
        if (this.nopScript) {
            return this.nopScript.clone().add(lockingScript);
        }
        return lockingScript;
    };
    Object.defineProperty(AbstractContract.prototype, "txContext", {
        get: function () {
            return this._txContext;
        },
        set: function (txContext) {
            this._txContext = txContext;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "sourceMapFile", {
        get: function () {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            return artifact.sourceMapFile;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "file", {
        get: function () {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            return artifact.file;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "contractName", {
        get: function () {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            return artifact.contract;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "stateProps", {
        get: function () {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            return artifact.stateProps || [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "version", {
        get: function () {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            return artifact.version || 0;
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.prototype.addFunctionCall = function (f) {
        this.calledPubFunctions.push(f);
    };
    Object.defineProperty(AbstractContract.prototype, "resolver", {
        get: function () {
            return Object.getPrototypeOf(this).constructor.resolver;
        },
        enumerable: false,
        configurable: true
    });
    // replace assembly variables with assembly values
    AbstractContract.prototype.replaceAsmVars = function (asmVarValues) {
        if (asmVarValues) {
            for (var key in asmVarValues) {
                var val = asmVarValues[key];
                this.hexTemplateInlineASM.set("<".concat(key.startsWith('$') ? key.substring(1) : key, ">"), internal_1.bsv.Script.fromASM(val).toHex());
            }
        }
        var hexTemplate = Object.getPrototypeOf(this).constructor.hex;
        var lockingScript = (0, internal_1.buildContractCode)(this.hexTemplateArgs, this.hexTemplateInlineASM, hexTemplate);
        this.scriptedConstructor.lockingScript = lockingScript;
    };
    Object.defineProperty(AbstractContract.prototype, "asmArgs", {
        // replace assembly variables with assembly values
        get: function () {
            var e_1, _a;
            var result = {};
            try {
                for (var _b = __values(this.hexTemplateInlineASM.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var entry = _c.value;
                    var name_1 = entry[0].replace('<', '').replace('>', '');
                    var value = entry[1];
                    result[name_1] = internal_1.bsv.Script.fromHex(value).toASM();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    /**
   * @param states an object. Each key of the object is the name of a state property, and each value is the value of the state property.
   * @returns a locking script that includes the new states. If you only provide some but not all state properties, other state properties are not modified when calculating the locking script.
   */
    AbstractContract.prototype.getNewStateScript = function (states) {
        var _this = this;
        var stateArgs = this.statePropsArgs;
        if (stateArgs.length === 0) {
            throw new Error("Contract ".concat(this.contractName, " does not have any stateful property"));
        }
        var resolveKeys = [];
        var newState = stateArgs.map(function (arg) {
            if (Object.prototype.hasOwnProperty.call(states, arg.name)) {
                resolveKeys.push(arg.name);
                var state = states[arg.name];
                state = _this.transformerArg(state, arg, true);
                var error = (0, typeCheck_1.checkSupportedParamType)(state, arg, _this.resolver);
                if (error) {
                    throw error;
                }
                return Object.assign(__assign({}, arg), {
                    value: state
                });
            }
            else {
                return arg;
            }
        });
        Object.keys(states).forEach(function (key) {
            if (resolveKeys.indexOf(key) === -1) {
                throw new Error("Contract ".concat(_this.contractName, " does not have stateful property ").concat(key));
            }
        });
        return this.codePart.add(internal_1.bsv.Script.fromHex(stateful_1.default.buildState(newState, false, this.resolver)));
    };
    AbstractContract.prototype.run_verify = function (unlockingScript, txContext) {
        var txCtx = Object.assign({}, this._txContext || {}, txContext || {});
        var us;
        if (typeof unlockingScript === 'string') {
            us = unlockingScript.trim() ? internal_1.bsv.Script.fromASM(unlockingScript.trim()) : new internal_1.bsv.Script('');
        }
        else {
            us = unlockingScript ? unlockingScript : new internal_1.bsv.Script('');
        }
        var ls = internal_1.bsv.Script.fromHex(this.lockingScript.toHex());
        var tx = typeof txCtx.tx === 'string' ? new internal_1.bsv.Transaction(txCtx.tx) : txCtx.tx;
        var inputIndex = txCtx.inputIndex;
        var inputSatoshis = txCtx.inputSatoshis;
        internal_1.bsv.Script.Interpreter.MAX_SCRIPT_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
        internal_1.bsv.Script.Interpreter.MAXIMUM_ELEMENT_SIZE = Number.MAX_SAFE_INTEGER;
        var bsi = new internal_1.bsv.Script.Interpreter();
        var failedAt = {};
        bsi.stepListener = function (step) {
            if (step.fExec || (internal_1.bsv.Opcode.OP_IF <= step.opcode.toNumber() && step.opcode.toNumber() <= internal_1.bsv.Opcode.OP_ENDIF)) {
                if ((internal_1.bsv.Opcode.OP_IF <= step.opcode.toNumber() && step.opcode.toNumber() <= internal_1.bsv.Opcode.OP_ENDIF) || step.opcode.toNumber() === internal_1.bsv.Opcode.OP_RETURN) /**Opreturn */ {
                    failedAt.opcode = step.opcode;
                }
                else {
                    failedAt = step;
                }
            }
        };
        var result = bsi.verify(us, ls, tx, inputIndex, internal_1.DEFAULT_FLAGS, new internal_1.bsv.crypto.BN(inputSatoshis));
        if (result) {
            return {
                success: true,
                error: ''
            };
        }
        if ((bsi.errstr || '').indexOf('SCRIPT_ERR_NULLFAIL') > -1) {
            if (!txCtx) {
                throw new Error('should provide txContext when verify');
            }
            if (!tx) {
                throw new Error('should provide txContext.tx when verify');
            }
        }
        failedAt.opcode = failedAt.opcode.toNumber();
        return {
            success: result,
            error: this.fmtError({
                error: bsi.errstr || '',
                failedAt: failedAt
            })
        };
    };
    /**
     * format the error
     * @param err the result output by  `tx.verifyInputScript(inputIndex)`
     * @returns string the formatted error message.
     */
    AbstractContract.prototype.fmtError = function (err) {
        var failedOpCode = err.failedAt.opcode;
        var error = "VerifyError: ".concat(err.error, ", fails at ").concat(new internal_1.bsv.Opcode(failedOpCode), "\n");
        if (this.sourceMapFile) {
            var sourceMapFilePath = (0, internal_1.uri2path)(this.sourceMapFile);
            var sourceMap = (0, internal_1.JSONParserSync)(sourceMapFilePath);
            var sourcePath = (0, internal_1.uri2path)(this.file);
            var srcDir_1 = (0, path_1.dirname)(sourcePath);
            var sourceFileName_1 = (0, path_1.basename)(sourcePath);
            var sources = sourceMap.sources.map(function (source) { return (0, compilerWrapper_1.getFullFilePath)(source, srcDir_1, sourceFileName_1); });
            var pos = (0, internal_1.findSrcInfoV2)(err.failedAt.pc, sourceMap);
            if (pos && sources[pos[1]]) {
                error = "VerifyError: ".concat(err.error, " \n\t[Go to Source](").concat((0, internal_1.path2uri)(sources[pos[1]]), "#").concat(pos[2], ")  fails at ").concat(new internal_1.bsv.Opcode(failedOpCode), "\n");
            }
        }
        else if (this.version <= 8) {
            var artifact = Object.getPrototypeOf(this).constructor.artifact;
            var sourceMap = (0, compilerWrapper_1.loadSourceMapfromArtifact)(artifact);
            if (sourceMap.length > 0) {
                // the complete script may have op_return and data, but compiled output does not have it. So we need to make sure the index is in boundary.
                var opcodeIndex = err.failedAt.pc;
                if (sourceMap[opcodeIndex]) {
                    var opcode = sourceMap[opcodeIndex];
                    if (!opcode.pos || opcode.pos.file === 'std') {
                        var srcInfo = (0, internal_1.findSrcInfoV1)(sourceMap, opcodeIndex);
                        if (srcInfo) {
                            opcode.pos = srcInfo.pos;
                        }
                    }
                    // in vscode termianal need to use [:] to jump to file line, but here need to use [#] to jump to file line in output channel.
                    if (opcode && opcode.pos) {
                        error = "VerifyError: ".concat(err.error, " \n\t[Go to Source](").concat((0, internal_1.path2uri)(opcode.pos.file), "#").concat(opcode.pos.line, ")  fails at ").concat(new internal_1.bsv.Opcode(failedOpCode), "\n");
                    }
                }
            }
        }
        return error;
    };
    /**
     * Generate a debugger launch configuration for the contract's last called public method
     * @param txContext
     * @returns a uri of the debugger launch configuration
     */
    AbstractContract.prototype.genLaunchConfig = function (txContext) {
        var txCtx = Object.assign({}, this.txContext || {}, txContext || {});
        var lastCalledPubFunction = this.lastCalledPubFunction();
        if (lastCalledPubFunction) {
            var debugUrl = lastCalledPubFunction.genLaunchConfig(txCtx);
            return "[Launch Debugger](".concat(debugUrl.replace(/file:/i, 'scryptlaunch:'), ")\n");
        }
        throw new Error('No public function called');
    };
    Object.defineProperty(AbstractContract.prototype, "dataPart", {
        get: function () {
            if (AbstractContract.isStateful(this)) {
                var state = stateful_1.default.buildState(this.statePropsArgs, this.isGenesis, this.resolver);
                return internal_1.bsv.Script.fromHex(state);
            }
            if (this._dataPartInHex) {
                return internal_1.bsv.Script.fromHex(this._dataPartInHex);
            }
        },
        set: function (dataInScript) {
            throw new Error('Setter for dataPart is not available. Please use: setDataPart() instead');
        },
        enumerable: false,
        configurable: true
    });
    /**
   * @deprecated use setDataPartInASM setDataPartInHex
   * set the data part of the contract
   * @param state
   * @param isStateHex
   */
    AbstractContract.prototype.setDataPart = function (state, isStateHex) {
        if (isStateHex === void 0) { isStateHex = false; }
        if (isStateHex == false) {
            console.warn('deprecated, using setDataPartInASM');
            this.setDataPartInASM(state);
        }
        else {
            console.warn('deprecated, using setDataPartInHex');
            this.setDataPartInHex(state);
        }
    };
    /**
   * set the data part of the contract in ASM format
   * @param asm
   * @param
   */
    AbstractContract.prototype.setDataPartInASM = function (asm) {
        if (AbstractContract.isStateful(this)) {
            throw new Error('should not use `setDataPartInASM` for a stateful contract, using `setDataPartInHex`');
        }
        var dataPartInASM = asm.trim();
        this.setDataPartInHex(internal_1.bsv.Script.fromASM(dataPartInASM).toHex());
    };
    /**
   * set the data part of the contract in hex format
   * @param hex
   */
    AbstractContract.prototype.setDataPartInHex = function (hex) {
        this._dataPartInHex = hex.trim();
        if (AbstractContract.isStateful(this)) {
            var _a = __read(stateful_1.default.parseStateHex(this, this._dataPartInHex), 2), isGenesis = _a[0], args = _a[1];
            this.statePropsArgs = args;
            this.isGenesis = isGenesis;
        }
    };
    AbstractContract.prototype.prependNOPScript = function (nopScript) {
        if (nopScript instanceof internal_1.bsv.Script) {
            (0, internal_1.checkNOPScript)(nopScript);
        }
        this.nopScript = nopScript;
    };
    AbstractContract.prototype.getPrependNOPScript = function () {
        return this.nopScript;
    };
    Object.defineProperty(AbstractContract.prototype, "codePart", {
        get: function () {
            var contractScript = this.scriptedConstructor.toScript();
            // note: do not trim the trailing space
            return this._wrapNOPScript(contractScript.clone()).add(internal_1.bsv.Script.fromHex('6a'));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "codeHash", {
        get: function () {
            if (this.dataPart) {
                return (0, internal_1.hash160)(this.codePart.toHex());
            }
            else {
                return (0, internal_1.hash160)(this.lockingScript.toHex());
            }
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.getAsmVars = function (lockingScriptHex) {
        var instance = this.fromHex(lockingScriptHex);
        return instance.asmArgs;
    };
    AbstractContract.prototype.arguments = function (pubFuncName) {
        if (pubFuncName === 'constructor') {
            return this.scriptedConstructor.args;
        }
        for (var i = this.calledPubFunctions.length - 1; i >= 0; i--) {
            var called = this.calledPubFunctions[i];
            if (called.methodName === pubFuncName) {
                return called.args;
            }
        }
        return [];
    };
    AbstractContract.prototype.lastCalledPubFunction = function () {
        var index = this.calledPubFunctions.length - 1;
        if (index < 0) {
            return undefined;
        }
        return this.calledPubFunctions[index];
    };
    AbstractContract.prototype.ctorArgs = function () {
        return this.arguments('constructor');
    };
    Object.defineProperty(AbstractContract.prototype, "asmVars", {
        /**
           * Get the parameter of the constructor and inline asm vars,
           * all values is hex string, need convert it to number or bytes on using
           */
        get: function () {
            return this.ContractClass.getAsmVars(this.scriptedConstructor.toHex());
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractContract.prototype, "ContractClass", {
        get: function () {
            return Object.getPrototypeOf(this).constructor;
        },
        enumerable: false,
        configurable: true
    });
    AbstractContract.prototype.transformerArgs = function (args, params, state) {
        var _this = this;
        return params.map(function (p, index) { return _this.transformerArg(args[index], p, state); });
    };
    AbstractContract.prototype.transformerArg = function (arg, param, state) {
        var _this = this;
        var typeInfo = this.resolver(param.type);
        if ((0, internal_1.isArrayType)(typeInfo.finalType)) {
            /* eslint-disable @typescript-eslint/no-unused-vars */
            var _a = __read((0, typeCheck_1.arrayTypeAndSize)(typeInfo.finalType), 2), _ = _a[0], arraySizes = _a[1];
            if (!Array.isArray(arg)) {
                return arg;
            }
            if (arg.length !== arraySizes[0]) {
                return arg;
            }
            var subType = (0, typeCheck_1.subArrayType)(param.type);
            var results = [];
            for (var i = 0; i < arraySizes[0]; i++) {
                var elem = arg[i];
                results.push(this.transformerArg(elem, {
                    name: "".concat(param.name).concat((0, internal_1.subscript)(i, arraySizes)),
                    type: subType
                }, state));
            }
            return results;
        }
        else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Library) {
            var entity = typeInfo.info;
            if (entity.name === 'HashedMap') {
                if (arg instanceof Map) {
                    if (state) {
                        return {
                            _data: this.ContractClass.toData(arg, param.type)
                        };
                    }
                    else {
                        return [this.ContractClass.toData(arg, param.type)];
                    }
                }
            }
            else if (entity.name === 'HashedSet') {
                if (arg instanceof Set) {
                    if (state) {
                        return {
                            _data: this.ContractClass.toData(arg, param.type)
                        };
                    }
                    else {
                        return [this.ContractClass.toData(arg, param.type)];
                    }
                }
            }
            var params = state ? entity.properties : entity.params;
            if (!state && Array.isArray(arg)) {
                return params.map(function (p, index) {
                    return _this.transformerArg(arg[index], p, state);
                });
            }
            else if (state && typeof arg === 'object') {
                return params.reduce(function (acc, p) {
                    var _a;
                    Object.assign(acc, (_a = {},
                        _a[p.name] = _this.transformerArg(arg[p.name], p, state),
                        _a));
                    return acc;
                }, {});
            }
        }
        else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
            if (!Array.isArray(arg) && typeof arg === 'object') {
                var entity = typeInfo.info;
                if (entity.name === 'SortedItem') {
                    if (arg['idx'] === (0, scryptTypes_1.Int)(-1) && (arg['image'] instanceof Map || arg['image'] instanceof Set)) {
                        /* eslint-disable @typescript-eslint/no-unused-vars */
                        var _b = __read((0, _1.parseGenericType)(typeInfo.finalType), 2), _ = _b[0], genericTypes = _b[1];
                        return Object.assign({}, {
                            idx: this.ContractClass.findKeyIndex(arg['image'], arg['item'], genericTypes[0]),
                            item: arg['item']
                        });
                    }
                    return arg;
                }
                var clone_1 = Object.assign({}, arg);
                entity.params.forEach(function (property) {
                    if (typeof arg[property.name] !== 'undefined') {
                        clone_1[property.name] = _this.transformerArg(arg[property.name], property, state);
                    }
                });
                return clone_1;
            }
        }
        else if (typeof arg === 'number') {
            return BigInt(arg);
        }
        return arg;
    };
    AbstractContract.prototype.checkArgs = function (funname, params) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (args.length !== params.length) {
            throw new Error("wrong number of arguments for '".concat(this.contractName, ".").concat(funname, "', expected ").concat(params.length, " but got ").concat(args.length));
        }
        var args_ = this.transformerArgs(args, params, false);
        params.forEach(function (param, index) {
            var arg = args_[index];
            var error = (0, typeCheck_1.checkSupportedParamType)(arg, param, _this.resolver);
            if (error)
                throw error;
        });
        return args_;
    };
    AbstractContract.fromASM = function (asm) {
        return this.fromHex(internal_1.bsv.Script.fromASM(asm).toHex());
    };
    AbstractContract.fromHex = function (hex) {
        this.asmContract = true;
        var ctor = this;
        var obj = new ctor();
        this.asmContract = false;
        obj.scriptedConstructor = this.abiCoder.encodeConstructorCallFromRawHex(obj, this.hex, hex);
        return obj;
    };
    AbstractContract.fromTransaction = function (hex, outputIndex) {
        if (outputIndex === void 0) { outputIndex = 0; }
        var tx = new internal_1.bsv.Transaction(hex);
        return this.fromHex(tx.outputs[outputIndex].script.toHex());
    };
    AbstractContract.isStateful = function (contract) {
        return contract.stateProps.length > 0;
    };
    // struct / array: sha256 every single element of the flattened struct / array, and concat the result to a joint byte, and sha256 again 
    // basic type: sha256 every single element
    AbstractContract.flattenSha256 = function (data, type) {
        var error = (0, typeCheck_1.checkSupportedParamType)(data, {
            name: '',
            type: type
        }, this.resolver);
        if (error)
            throw error;
        var flattened = (0, typeCheck_1.flatternArg)({
            name: '',
            type: type,
            value: data
        }, this.resolver, {
            state: true,
            ignoreValue: false
        });
        if (flattened.length === 1) {
            var hex = stateful_1.default.serialize(flattened[0].value, flattened[0].type);
            return internal_1.bsv.crypto.Hash.sha256(Buffer.from(hex, 'hex')).toString('hex');
        }
        else {
            var jointbytes = flattened.map(function (item) {
                var hex = stateful_1.default.serialize(item.value, item.type);
                return internal_1.bsv.crypto.Hash.sha256(Buffer.from(hex, 'hex')).toString('hex');
            }).join('');
            return internal_1.bsv.crypto.Hash.sha256(Buffer.from(jointbytes, 'hex')).toString('hex');
        }
    };
    // sort the map by the result of flattenSha256 of the key
    AbstractContract.sortmap = function (map, keyType) {
        var _this = this;
        return new Map(__spreadArray([], __read(map.entries()), false).sort(function (a, b) {
            return internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(a[0], keyType), 'hex'), {
                endian: 'little'
            }).cmp(internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(b[0], keyType), 'hex'), {
                endian: 'little'
            }));
        }));
    };
    // sort the set by the result of flattenSha256 of the key
    AbstractContract.sortset = function (set, keyType) {
        var _this = this;
        return new Set(__spreadArray([], __read(set.keys()), false).sort(function (a, b) {
            return internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(a, keyType), 'hex'), {
                endian: 'little'
            }).cmp(internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(b, keyType), 'hex'), {
                endian: 'little'
            }));
        }));
    };
    AbstractContract.sortkeys = function (keys, keyType) {
        var _this = this;
        return keys.sort(function (a, b) {
            return internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(a, keyType), 'hex'), {
                endian: 'little'
            }).cmp(internal_1.bsv.crypto.BN.fromSM(Buffer.from(_this.flattenSha256(b, keyType), 'hex'), {
                endian: 'little'
            }));
        });
    };
    // returns index of the HashedMap/HashedSet by the key
    AbstractContract.findKeyIndex = function (collection, key, keyType) {
        var keys = __spreadArray([], __read(collection.keys()), false);
        keys.push(key);
        var sortedKeys = this.sortkeys(keys, keyType);
        var index = sortedKeys.findIndex(function (entry) {
            if (entry === key) {
                return true;
            }
            return false;
        });
        return BigInt(index);
    };
    //serialize the HashedMap / HashedSet, but only flattenSha256 of the key and value
    AbstractContract.toData = function (collection, collectionType) {
        var e_2, _a, e_3, _b;
        /* eslint-disable @typescript-eslint/no-unused-vars */
        var _c = __read((0, _1.parseGenericType)(collectionType), 2), _ = _c[0], genericTypes = _c[1];
        var storage = '';
        if (collection instanceof Map) {
            var sortedMap = this.sortmap(collection, genericTypes[0]);
            try {
                for (var _d = __values(sortedMap.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var entry = _e.value;
                    storage += this.flattenSha256(entry[0], genericTypes[0]) + this.flattenSha256(entry[1], genericTypes[1]);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else {
            var sortedSet = this.sortset(collection, genericTypes[0]);
            try {
                for (var _f = __values(sortedSet.keys()), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var key = _g.value;
                    storage += this.flattenSha256(key, genericTypes[0]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return (0, scryptTypes_1.Bytes)(storage);
    };
    return AbstractContract;
}());
exports.AbstractContract = AbstractContract;
var invalidMethodName = ['arguments',
    'setDataPart',
    'setDataPartInASM',
    'setDataPartInHex',
    'version',
    'stateProps',
    'sourceMapFile',
    'file',
    'contractName',
    'ctorArgs',
    'run_verify',
    'replaceAsmVars',
    'asmVars',
    'asmArguments',
    'dataPart',
    'lockingScript',
    'codeHash',
    'codePart',
    'resolver',
    'getNewStateScript',
    'txContext'];
function buildContractClass(artifact) {
    if (artifact instanceof internal_1.CompileResult) {
        artifact = artifact.toArtifact();
    }
    if (!artifact.contract) {
        throw new Error('Missing field `contract` in artifact');
    }
    if (!artifact.version) {
        throw new Error('Missing field `version` in artifact');
    }
    if (artifact.version < exports.SUPPORTED_MINIMUM_VERSION) {
        throw new Error("Contract artifact version deprecated, The minimum version number currently supported is ".concat(exports.SUPPORTED_MINIMUM_VERSION));
    }
    if (!artifact.abi) {
        throw new Error('Missing field `abi` in artifact');
    }
    if (!artifact.hex) {
        throw new Error('Missing field `hex` in artifact');
    }
    var ContractClass = /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _a;
            var ctorParams = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                ctorParams[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            if (!ContractClass.asmContract) {
                _this.scriptedConstructor = (_a = ContractClass.abiCoder).encodeConstructorCall.apply(_a, __spreadArray([_this, ContractClass.hex], __read(ctorParams), false));
            }
            return _this;
        }
        return class_1;
    }(AbstractContract));
    ContractClass.artifact = artifact;
    ContractClass.resolver = buildTypeResolverFromArtifact(artifact);
    ContractClass.abi = artifact.abi;
    ContractClass.hex = artifact.hex;
    ContractClass.abiCoder = new internal_1.ABICoder(artifact.abi, ContractClass.resolver, artifact.contract);
    ContractClass.stateProps = artifact.stateProps || [];
    ContractClass.abi.forEach(function (entity) {
        if (entity.type === _1.ABIEntityType.CONSTRUCTOR) {
            return;
        }
        if (!entity.name || invalidMethodName.indexOf(entity.name) > -1) {
            throw new Error("Method name [".concat(entity.name, "] is used by scryptlib now, Pelease change you contract method name!"));
        }
        ContractClass.prototype[entity.name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var call = ContractClass.abiCoder.encodePubFunctionCall(this, entity.name || '', args);
            this.addFunctionCall(call);
            return call;
        };
    });
    ContractClass.stateProps.forEach(function (p) {
        Object.defineProperty(ContractClass.prototype, p.name, {
            get: function () {
                var arg = this.statePropsArgs.find(function (arg) {
                    return arg.name === p.name;
                });
                if (arg) {
                    return arg.value;
                }
                else {
                    throw new Error("property ".concat(p.name, " does not exists"));
                }
            },
            set: function (value) {
                var arg = this.statePropsArgs.find(function (arg) {
                    return arg.name === p.name;
                });
                if (arg) {
                    value = this.transformerArg(value, arg, true);
                    var error = (0, typeCheck_1.checkSupportedParamType)(value, arg, this.resolver);
                    if (error)
                        throw error;
                    arg.value = value;
                    this.isGenesis = false;
                }
                else {
                    throw new Error("property ".concat(p.name, " does not exists"));
                }
            }
        });
    });
    return ContractClass;
}
exports.buildContractClass = buildContractClass;
function buildTypeResolverFromArtifact(artifact) {
    var alias = artifact.alias || [];
    var library = artifact.library || [];
    var structs = artifact.structs || [];
    var contract = artifact.contract;
    return buildTypeResolver(contract, alias, structs, library);
}
exports.buildTypeResolverFromArtifact = buildTypeResolverFromArtifact;
// build a resolver witch can only resolve type
function buildTypeResolver(contract, alias, structs, library, contracts, statics) {
    if (contracts === void 0) { contracts = []; }
    if (statics === void 0) { statics = []; }
    var resolvedTypes = {};
    structs.forEach(function (element) {
        resolvedTypes[element.name] = {
            info: element,
            generic: (0, typeCheck_1.hasGeneric)(element),
            finalType: element.name,
            symbolType: scryptTypes_1.SymbolType.Struct
        };
    });
    library.forEach(function (element) {
        resolvedTypes[element.name] = {
            info: element,
            generic: (0, typeCheck_1.hasGeneric)(element),
            finalType: element.name,
            symbolType: scryptTypes_1.SymbolType.Library
        };
    });
    contracts.forEach(function (element) {
        resolvedTypes[element.name] = {
            info: element,
            generic: (0, typeCheck_1.hasGeneric)(element),
            finalType: element.name,
            symbolType: scryptTypes_1.SymbolType.Contract
        };
    });
    // add std type
    resolvedTypes['HashedMap'] = {
        info: {
            name: 'HashedMap',
            params: [
                {
                    name: '_data',
                    type: 'bytes'
                }
            ],
            properties: [
                {
                    name: '_data',
                    type: 'bytes'
                }
            ],
            genericTypes: ['K', 'V']
        },
        generic: true,
        finalType: 'HashedMap',
        symbolType: scryptTypes_1.SymbolType.Library
    };
    resolvedTypes['HashedSet'] = {
        info: {
            name: 'HashedSet',
            params: [
                {
                    name: '_data',
                    type: 'bytes'
                }
            ],
            properties: [
                {
                    name: '_data',
                    type: 'bytes'
                }
            ],
            genericTypes: ['E']
        },
        generic: true,
        finalType: 'HashedSet',
        symbolType: scryptTypes_1.SymbolType.Library
    };
    resolvedTypes['SortedItem'] = {
        info: {
            name: 'SortedItem',
            params: [
                {
                    name: 'item',
                    type: 'T'
                },
                {
                    name: 'idx',
                    type: 'int'
                }
            ],
            genericTypes: ['T']
        },
        generic: true,
        finalType: 'SortedItem',
        symbolType: scryptTypes_1.SymbolType.Struct
    };
    resolvedTypes['PubKeyHash'] = {
        finalType: 'Ripemd160',
        generic: false,
        symbolType: scryptTypes_1.SymbolType.ScryptType
    };
    var resolver = function (type) {
        if (resolvedTypes[type]) {
            return resolvedTypes[type];
        }
        if ((0, scryptTypes_1.isScryptType)(type)) {
            return {
                generic: false,
                finalType: type,
                symbolType: scryptTypes_1.SymbolType.ScryptType
            };
        }
        return (0, internal_1.resolveType)(type, resolvedTypes, contract, statics, alias, library);
    };
    return resolver;
}
exports.buildTypeResolver = buildTypeResolver;
//# sourceMappingURL=contract.js.map