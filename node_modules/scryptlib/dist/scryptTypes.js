"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBytes = exports.isSubBytes = exports.isScryptType = exports.getValidatedHexString = exports.getSortedItem = exports.OpCodeType = exports.SigHashPreimage = exports.SigHashType = exports.SignatureHashType = exports.HashedMap = exports.HashedSet = exports.Sha256 = exports.Sha1 = exports.PubKeyHash = exports.Ripemd160 = exports.Sig = exports.PubKey = exports.PrivKey = exports.Bytes = exports.Bool = exports.Int = exports.ScryptType = exports.SymbolType = void 0;
var SymbolType;
(function (SymbolType) {
    SymbolType["ScryptType"] = "ScryptType";
    SymbolType["Contract"] = "Contract";
    SymbolType["Library"] = "Library";
    SymbolType["Struct"] = "Struct";
    SymbolType["Unknown"] = "Unknown";
})(SymbolType = exports.SymbolType || (exports.SymbolType = {}));
var ScryptType;
(function (ScryptType) {
    ScryptType["BOOL"] = "bool";
    ScryptType["INT"] = "int";
    ScryptType["BYTES"] = "bytes";
    ScryptType["PUBKEY"] = "PubKey";
    ScryptType["PRIVKEY"] = "PrivKey";
    ScryptType["SIG"] = "Sig";
    ScryptType["RIPEMD160"] = "Ripemd160";
    ScryptType["SHA1"] = "Sha1";
    ScryptType["SHA256"] = "Sha256";
    ScryptType["SIGHASHTYPE"] = "SigHashType";
    ScryptType["SIGHASHPREIMAGE"] = "SigHashPreimage";
    ScryptType["OPCODETYPE"] = "OpCodeType";
})(ScryptType = exports.ScryptType || (exports.ScryptType = {}));
function Int(n) {
    return BigInt(n);
}
exports.Int = Int;
function Bool(b) {
    return b;
}
exports.Bool = Bool;
function Bytes(b) {
    return getValidatedHexString(b);
}
exports.Bytes = Bytes;
function PrivKey(n) {
    return n;
}
exports.PrivKey = PrivKey;
function PubKey(b) {
    return getValidatedHexString(b, false);
}
exports.PubKey = PubKey;
function Sig(b) {
    return getValidatedHexString(b, false);
}
exports.Sig = Sig;
function Ripemd160(b) {
    return getValidatedHexString(b, false);
}
exports.Ripemd160 = Ripemd160;
function PubKeyHash(b) {
    return Ripemd160(b);
}
exports.PubKeyHash = PubKeyHash;
function Sha1(b) {
    return getValidatedHexString(b, false);
}
exports.Sha1 = Sha1;
function Sha256(b) {
    return getValidatedHexString(b, false);
}
exports.Sha256 = Sha256;
function HashedSet(set) {
    return set;
}
exports.HashedSet = HashedSet;
function HashedMap(map) {
    return map;
}
exports.HashedMap = HashedMap;
var SignatureHashType;
(function (SignatureHashType) {
    SignatureHashType[SignatureHashType["ALL"] = 65] = "ALL";
    SignatureHashType[SignatureHashType["NONE"] = 66] = "NONE";
    SignatureHashType[SignatureHashType["SINGLE"] = 67] = "SINGLE";
    SignatureHashType[SignatureHashType["ANYONECANPAY_ALL"] = 193] = "ANYONECANPAY_ALL";
    SignatureHashType[SignatureHashType["ANYONECANPAY_NONE"] = 194] = "ANYONECANPAY_NONE";
    SignatureHashType[SignatureHashType["ANYONECANPAY_SINGLE"] = 195] = "ANYONECANPAY_SINGLE";
})(SignatureHashType = exports.SignatureHashType || (exports.SignatureHashType = {}));
function SigHashType(s) {
    if (s == 0) {
        return '00';
    }
    else if (s === SignatureHashType.ALL || s === SignatureHashType.NONE || s === SignatureHashType.SINGLE
        || s === SignatureHashType.ANYONECANPAY_ALL || s === SignatureHashType.ANYONECANPAY_NONE || s === SignatureHashType.ANYONECANPAY_SINGLE) {
        return "".concat(s.toString(16));
    }
    throw new Error("unsupported SigHashType: ".concat(s));
}
exports.SigHashType = SigHashType;
function SigHashPreimage(b) {
    return getValidatedHexString(b, false);
}
exports.SigHashPreimage = SigHashPreimage;
function OpCodeType(b) {
    return getValidatedHexString(b, false);
}
exports.OpCodeType = OpCodeType;
function getSortedItem(collection, k) {
    return Object.assign({
        idx: Int(-1),
        item: k
    }, {
        image: collection instanceof Map ? new Map(collection) : new Set(collection)
    });
}
exports.getSortedItem = getSortedItem;
function getValidatedHexString(hex, allowEmpty) {
    if (allowEmpty === void 0) { allowEmpty = true; }
    var ret = hex.trim();
    if (ret.length < 1 && !allowEmpty) {
        throw new Error('can\'t be empty string');
    }
    if (ret.length % 2) {
        throw new Error("<".concat(ret, "> should have even length"));
    }
    if (ret.length > 0 && !(/^[\da-f]+$/i.test(ret))) {
        throw new Error("<".concat(ret, "> should only contain [0-9] or characters [a-fA-F]"));
    }
    return ret;
}
exports.getValidatedHexString = getValidatedHexString;
function isScryptType(type) {
    return Object.keys(ScryptType).map(function (key) { return ScryptType[key]; }).includes(type);
}
exports.isScryptType = isScryptType;
function isSubBytes(type) {
    return [ScryptType.OPCODETYPE, ScryptType.PUBKEY, ScryptType.RIPEMD160, ScryptType.SHA1, ScryptType.SHA256, ScryptType.SIG,
        // eslint-disable-next-line indent
        ScryptType.SIGHASHPREIMAGE, ScryptType.SIGHASHTYPE, 'PubKeyHash'].map(function (t) { return t.toString(); }).includes(type);
}
exports.isSubBytes = isSubBytes;
function isBytes(type) {
    return type === ScryptType.BYTES || isSubBytes(type);
}
exports.isBytes = isBytes;
//# sourceMappingURL=scryptTypes.js.map