"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeArgfromHex = exports.createArray = exports.createLibrary = exports.createStruct = exports.deserializer = exports.hex2bytes = exports.hex2bool = exports.hex2int = void 0;
var _1 = require(".");
var scryptTypes_1 = require("./scryptTypes");
var stateful_1 = require("./stateful");
var utils_1 = require("./utils");
/**
 * little-endian signed magnitude to int
 */
function hex2int(hex) {
    if (hex === '00') {
        return (0, scryptTypes_1.Int)(0);
    }
    else if (hex === '4f') {
        return (0, scryptTypes_1.Int)(-1);
    }
    else {
        var b = utils_1.bsv.Script.fromHex(hex);
        var chuck = b.chunks[0];
        if (chuck.opcodenum >= 81 && chuck.opcodenum <= 96) {
            return BigInt(chuck.opcodenum - 80);
        }
        return (0, _1.bin2num)(chuck.buf.toString('hex'));
    }
}
exports.hex2int = hex2int;
function hex2bool(hex) {
    if (hex === '51') {
        return true;
    }
    else if (hex === '00') {
        return false;
    }
    throw new Error("invalid hex ".concat(hex));
}
exports.hex2bool = hex2bool;
function hex2bytes(hex) {
    if (hex === '00') {
        return '';
    }
    var s = utils_1.bsv.Script.fromHex(hex);
    var chuck = s.chunks[0];
    if (chuck.opcodenum >= 81 && chuck.opcodenum <= 96) {
        return Buffer.from([chuck.opcodenum - 80]).toString('hex');
    }
    return chuck.buf.toString('hex');
}
exports.hex2bytes = hex2bytes;
function deserializer(type, hex) {
    switch (type) {
        case scryptTypes_1.ScryptType.BOOL:
            return (0, scryptTypes_1.Bool)(hex2bool(hex));
        case scryptTypes_1.ScryptType.INT:
            return (0, scryptTypes_1.Int)(hex2int(hex));
        case scryptTypes_1.ScryptType.BYTES:
            return (0, scryptTypes_1.Bytes)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.PRIVKEY:
            return (0, scryptTypes_1.PrivKey)(hex2int(hex));
        case scryptTypes_1.ScryptType.PUBKEY:
            return (0, scryptTypes_1.PubKey)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.SIG:
            return (0, scryptTypes_1.Sig)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.RIPEMD160:
            return (0, scryptTypes_1.Ripemd160)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.SHA1:
            return (0, scryptTypes_1.Sha1)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.SHA256:
            return (0, scryptTypes_1.Sha256)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.SIGHASHTYPE:
            return (0, scryptTypes_1.SigHashType)(Number(hex2int(hex)));
        case scryptTypes_1.ScryptType.SIGHASHPREIMAGE:
            return (0, scryptTypes_1.SigHashPreimage)(hex2bytes(hex));
        case scryptTypes_1.ScryptType.OPCODETYPE:
            return (0, scryptTypes_1.OpCodeType)(hex2bytes(hex));
        default:
            throw new Error("<".concat(type, "> cannot be cast to ScryptType, only sCrypt native types supported"));
    }
}
exports.deserializer = deserializer;
function createStruct(resolver, param, opcodesMap, options) {
    var structTypeInfo = resolver(param.type);
    var entity = structTypeInfo.info;
    var obj = Object.create({});
    entity.params.forEach(function (p) {
        var _a, _b, _c, _d, _e;
        var typeInfo = resolver(p.type);
        if ((0, _1.isArrayType)(typeInfo.finalType)) {
            Object.assign(obj, (_a = {},
                _a[p.name] = createArray(resolver, typeInfo.finalType, "".concat(param.name, ".").concat(p.name), opcodesMap, options),
                _a));
        }
        else if (typeInfo.symbolType === _1.SymbolType.Struct) {
            Object.assign(obj, (_b = {},
                _b[p.name] = createStruct(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options),
                _b));
        }
        else if (typeInfo.symbolType === _1.SymbolType.Library) {
            Object.assign(obj, (_c = {},
                _c[p.name] = createLibrary(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options),
                _c));
        }
        else {
            if (options.state) {
                Object.assign(obj, (_d = {},
                    _d[p.name] = stateful_1.default.deserializer(typeInfo.finalType, opcodesMap.get("<".concat(param.name, ".").concat(p.name, ">"))),
                    _d));
            }
            else {
                Object.assign(obj, (_e = {},
                    _e[p.name] = deserializer(typeInfo.finalType, opcodesMap.get("<".concat(param.name, ".").concat(p.name, ">"))),
                    _e));
            }
        }
    });
    return obj;
}
exports.createStruct = createStruct;
function createLibrary(resolver, param, opcodesMap, options) {
    var libraryTypeInfo = resolver(param.type);
    var entity = libraryTypeInfo.info;
    if (options.state) {
        var properties_1 = {};
        entity.properties.forEach(function (p) {
            var _a, _b, _c, _d;
            var typeInfo = resolver(p.type);
            if ((0, _1.isArrayType)(typeInfo.finalType)) {
                Object.assign(properties_1, (_a = {},
                    _a[p.name] = createArray(resolver, p.type, "".concat(param.name, ".").concat(p.name), opcodesMap, options),
                    _a));
            }
            else if (typeInfo.symbolType === _1.SymbolType.Struct) {
                Object.assign(properties_1, (_b = {},
                    _b[p.name] = createStruct(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options),
                    _b));
            }
            else if (typeInfo.symbolType === _1.SymbolType.Library) {
                Object.assign(properties_1, (_c = {},
                    _c[p.name] = createLibrary(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options),
                    _c));
            }
            else {
                Object.assign(properties_1, (_d = {},
                    _d[p.name] = stateful_1.default.deserializer(typeInfo.finalType, opcodesMap.get("<".concat(param.name, ".").concat(p.name, ">"))),
                    _d));
            }
        });
        return properties_1;
    }
    else {
        return entity.params.map(function (p) {
            var typeInfo = resolver(p.type);
            if ((0, _1.isArrayType)(typeInfo.finalType)) {
                return createArray(resolver, typeInfo.finalType, "".concat(param.name, ".").concat(p.name), opcodesMap, options);
            }
            else if (typeInfo.symbolType === _1.SymbolType.Struct) {
                return createStruct(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options);
            }
            else if (typeInfo.symbolType === _1.SymbolType.Library) {
                return createLibrary(resolver, { name: "".concat(param.name, ".").concat(p.name), type: p.type }, opcodesMap, options);
            }
            else {
                return deserializer(typeInfo.finalType, opcodesMap.get("<".concat(param.name, ".").concat(p.name, ">")));
            }
        });
    }
}
exports.createLibrary = createLibrary;
function createArray(resolver, type, name, opcodesMap, options) {
    var arrays = [];
    var _a = __read((0, _1.arrayTypeAndSize)(type), 2), elemTypeName = _a[0], sizes = _a[1];
    var arraylen = sizes[0];
    if (sizes.length === 1) {
        for (var index = 0; index < arraylen; index++) {
            var typeInfo = resolver(elemTypeName);
            if (typeInfo.symbolType === _1.SymbolType.Struct) {
                arrays.push(createStruct(resolver, {
                    name: "".concat(name, "[").concat(index, "]"),
                    type: typeInfo.finalType
                }, opcodesMap, options));
            }
            else if (typeInfo.symbolType === _1.SymbolType.Library) {
                arrays.push(createLibrary(resolver, {
                    name: "".concat(name, "[").concat(index, "]"),
                    type: typeInfo.finalType
                }, opcodesMap, options));
            }
            else {
                if (options.state) {
                    arrays.push(stateful_1.default.deserializer(typeInfo.finalType, opcodesMap.get("<".concat(name, "[").concat(index, "]>"))));
                }
                else {
                    arrays.push(deserializer(typeInfo.finalType, opcodesMap.get("<".concat(name, "[").concat(index, "]>"))));
                }
            }
        }
    }
    else {
        for (var index = 0; index < arraylen; index++) {
            var finalType = resolver(elemTypeName).finalType;
            var subArrayType = [finalType, sizes.slice(1).map(function (size) { return "[".concat(size, "]"); }).join('')].join('');
            arrays.push(createArray(resolver, subArrayType, "".concat(name, "[").concat(index, "]"), opcodesMap, options));
        }
    }
    return arrays;
}
exports.createArray = createArray;
function deserializeArgfromHex(resolver, arg, opcodesMap, options) {
    var value;
    var typeInfo = resolver(arg.type);
    if ((0, _1.isArrayType)(typeInfo.finalType)) {
        value = createArray(resolver, arg.type, arg.name, opcodesMap, options);
    }
    else if (typeInfo.symbolType === _1.SymbolType.Struct) {
        value = createStruct(resolver, arg, opcodesMap, options);
    }
    else if (typeInfo.symbolType === _1.SymbolType.Library) {
        value = createLibrary(resolver, arg, opcodesMap, options);
    }
    else {
        if (options.state) {
            value = stateful_1.default.deserializer(arg.type, opcodesMap.get("<".concat(arg.name, ">")));
        }
        else {
            value = deserializer(arg.type, opcodesMap.get("<".concat(arg.name, ">")));
        }
    }
    arg.value = value;
    return arg;
}
exports.deserializeArgfromHex = deserializeArgfromHex;
//# sourceMappingURL=deserializer.js.map