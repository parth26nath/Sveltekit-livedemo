"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveGenericType = exports.parseGenericType = exports.isGenericType = exports.resolveType = exports.findStatic = exports.findConstStatic = exports.flatternArg = exports.deduceGenericLibrary = exports.deduceGenericStruct = exports.hasGeneric = exports.checkSupportedParamType = exports.subArrayType = exports.toLiteralArrayType = exports.arrayTypeAndSize = exports.arrayTypeAndSizeStr = exports.typeOfArg = void 0;
var _1 = require(".");
var internal_1 = require("./internal");
var scryptTypes_1 = require("./scryptTypes");
function typeOfArg(a) {
    if (typeof a === 'bigint') {
        return 'int';
    }
    else if (typeof a === 'boolean') {
        return 'bool';
    }
    else if (typeof a === 'string') {
        return 'bytes';
    }
    else if (Array.isArray(a)) {
        return 'Array';
    }
    else {
        return typeof a;
    }
}
exports.typeOfArg = typeOfArg;
/**
 * return eg. int[N][N][4] => ['int', ["N","N","4"]]
 * @param arrayTypeName
 */
function arrayTypeAndSizeStr(arrayTypeName) {
    var arraySizes = [];
    if (arrayTypeName.indexOf('>') > -1) {
        var elemTypeName_1 = arrayTypeName.substring(0, arrayTypeName.lastIndexOf('>') + 1);
        var sizeParts = arrayTypeName.substring(arrayTypeName.lastIndexOf('>') + 1);
        __spreadArray([], __read(sizeParts.matchAll(/\[([\w.]+)\]+/g)), false).map(function (match) {
            arraySizes.push(match[1]);
        });
        return [elemTypeName_1, arraySizes];
    }
    __spreadArray([], __read(arrayTypeName.matchAll(/\[([\w.]+)\]+/g)), false).map(function (match) {
        arraySizes.push(match[1]);
    });
    var group = arrayTypeName.split('[');
    var elemTypeName = group[0];
    return [elemTypeName, arraySizes];
}
exports.arrayTypeAndSizeStr = arrayTypeAndSizeStr;
/**
 * return eg. int[2][3][4] => ['int', [2,3,4]]
 * @param arrayTypeName  eg. int[2][3][4]
 */
function arrayTypeAndSize(arrayTypeName) {
    var _a = __read(arrayTypeAndSizeStr(arrayTypeName), 2), elemTypeName = _a[0], arraySizes = _a[1];
    return [elemTypeName, arraySizes.map(function (size) {
            var n = parseInt(size);
            if (isNaN(n)) {
                throw new Error("arrayTypeAndSize error type ".concat(arrayTypeName, " with sub isNaN"));
            }
            return n;
        })];
}
exports.arrayTypeAndSize = arrayTypeAndSize;
function toLiteralArrayType(elemTypeName, sizes) {
    return [elemTypeName, sizes.map(function (size) { return "[".concat(size, "]"); }).join('')].join('');
}
exports.toLiteralArrayType = toLiteralArrayType;
/**
 * return eg. int[2][3][4] => int[3][4]
 * @param arrayTypeName  eg. int[2][3][4]
 */
function subArrayType(arrayTypeName) {
    var _a = __read(arrayTypeAndSize(arrayTypeName), 2), elemTypeName = _a[0], sizes = _a[1];
    return toLiteralArrayType(elemTypeName, sizes.slice(1));
}
exports.subArrayType = subArrayType;
function checkArrayParamType(args, param, resolver) {
    var typeInfo = resolver(param.type);
    var expectedType = typeInfo.finalType;
    var _a = __read(arrayTypeAndSize(expectedType), 2), elemTypeName = _a[0], arraySizes = _a[1];
    if (!Array.isArray(args)) {
        return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(expectedType, " but got ").concat(typeOfArg(args)));
    }
    if (args.length !== arraySizes[0]) {
        return new Error("The type of ".concat(param.name, " is wrong, expected a array with length = ").concat(arraySizes[0], " but got a array with length = ").concat(args.length, " "));
    }
    if (arraySizes.length == 1) {
        return args.map(function (arg) {
            return checkSupportedParamType(arg, {
                name: param.name,
                type: elemTypeName
            }, resolver);
        }).find(function (e) { return e instanceof Error; });
    }
    else {
        return args.map(function (a) {
            return checkArrayParamType(a, {
                name: param.name,
                type: subArrayType(expectedType)
            }, resolver);
        }).find(function (e) { return e instanceof Error; });
    }
}
function checkStructParamType(arg, param, resolver) {
    var typeInfo = resolver(param.type);
    if (!typeInfo.info) {
        return new Error("The type of ".concat(param.name, " is wrong, no info found"));
    }
    var entity = typeInfo.info;
    if (typeInfo.generic) {
        var result = deduceGenericStruct(param, entity, resolver);
        if (result instanceof Error) {
            return result;
        }
        entity = result;
    }
    if (Array.isArray(arg)) {
        return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but got a array"));
    }
    if (typeof arg !== 'object') {
        return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but got a ").concat(typeof arg));
    }
    var error = entity.params.map(function (p) {
        if (!Object.keys(arg).includes(p.name)) {
            return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but missing member [").concat(p.name, "]"));
        }
        return checkSupportedParamType(arg[p.name], p, resolver);
    }).find(function (e) { return e instanceof Error; });
    if (error) {
        return error;
    }
    var members = entity.params.map(function (p) { return p.name; });
    return Object.keys(arg).map(function (key) {
        if (!members.includes(key)) {
            return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but redundant member [").concat(key, "] appears"));
        }
        return undefined;
    }).find(function (e) { return e instanceof Error; });
}
function checkLibraryParamType(args, param, resolver) {
    var typeInfo = resolver(param.type);
    if (!typeInfo.info || typeInfo.symbolType !== scryptTypes_1.SymbolType.Library) {
        return new Error("The type of ".concat(param.name, " is wrong, no info found"));
    }
    var entity = typeInfo.info;
    if (typeInfo.generic) {
        var result = deduceGenericLibrary(param, entity, resolver);
        if (result instanceof Error) {
            return result;
        }
        entity = result;
    }
    if (Array.isArray(args)) {
        if (args.length !== entity.params.length) {
            return new Error("The type of ".concat(param.name, " is wrong, expected a array with length = ").concat(entity.params.length, " but got a array with length = ").concat(args.length, " "));
        }
        return entity.params.map(function (p, index) {
            if (typeof args[index] === 'undefined') {
                return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but missing parameter [").concat(p.name, "]"));
            }
            return checkSupportedParamType(args[index], p, resolver);
        }).find(function (e) { return e instanceof Error; });
    }
    else if (typeof args === 'object') {
        return entity.properties.map(function (p) {
            if (typeof args[p.name] === 'undefined') {
                return new Error("The type of ".concat(param.name, " is wrong, expected ").concat(entity.name, " but missing property [").concat(p.name, "]"));
            }
            return checkSupportedParamType(args[p.name], p, resolver);
        }).find(function (e) { return e instanceof Error; });
    }
    else {
        return new Error("The type of ".concat(param.name, " is wrong, expected a array or a object but got ").concat(typeof args));
    }
}
function checkSupportedParamType(arg, param, resolver) {
    var typeInfo = resolver(param.type);
    var expectedType = typeInfo.finalType;
    if ((0, _1.isArrayType)(expectedType)) {
        return checkArrayParamType(arg, param, resolver);
    }
    else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
        return checkStructParamType(arg, param, resolver);
    }
    else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Library) {
        return checkLibraryParamType(arg, param, resolver);
    }
    else if (typeInfo.symbolType === scryptTypes_1.SymbolType.ScryptType) {
        var error = new Error("The type of ".concat(param.name, " is wrong, expected ").concat(expectedType, " but got ").concat(typeOfArg(arg)));
        var t = typeOfArg(arg);
        if ((0, scryptTypes_1.isBytes)(expectedType)) {
            return t === scryptTypes_1.ScryptType.BYTES ? undefined : error;
        }
        else if (expectedType === scryptTypes_1.ScryptType.PRIVKEY) {
            return t === 'int' ? undefined : error;
        }
        else {
            return t == expectedType ? undefined : error;
        }
    }
    else {
        return new Error("can't not resolve type: ".concat(param.type));
    }
}
exports.checkSupportedParamType = checkSupportedParamType;
function hasGeneric(entity) {
    return entity.genericTypes.length > 0;
}
exports.hasGeneric = hasGeneric;
var GenericDeducer = /** @class */ (function () {
    function GenericDeducer(entity, resolver) {
        this.entity = entity;
        this.resolver = resolver;
        this.inferred = {};
    }
    GenericDeducer.prototype.resolve = function (type) {
        var _this = this;
        if (Object.keys(this.inferred).length > 0) {
            if (isGenericType(type)) {
                var _a = __read(parseGenericType(type), 2), name_1 = _a[0], types = _a[1];
                return (0, internal_1.toGenericType)(name_1, types.map(function (t) { return _this.inferred[t] || t; }));
            }
            if ((0, _1.isArrayType)(type)) {
                var _b = __read(arrayTypeAndSizeStr(type), 2), elem = _b[0], sizes = _b[1];
                return toLiteralArrayType(elem, sizes.map(function (t) { return _this.inferred[t] || t; }));
            }
            return this.inferred[type] || type;
        }
        return type;
    };
    GenericDeducer.prototype.inferr = function (param) {
        var _this = this;
        var typeInfo = this.resolver(param.type);
        var _a = __read(parseGenericType(typeInfo.finalType), 2), name = _a[0], genericTypes = _a[1];
        if (this.entity.name !== name) {
            return new Error("Generic inference failed, expected ".concat(name, " but got ").concat(this.entity.name));
        }
        if (this.entity.genericTypes.length !== genericTypes.length) {
            return new Error('Generic inference failed, genericTypes length not match');
        }
        return this.entity.genericTypes.map(function (genericTyp, index) {
            var realType = genericTypes[index];
            return _this.assert(genericTyp, realType);
        }).find(function (e) { return e instanceof Error; });
    };
    GenericDeducer.prototype.getEntity = function () {
        var _this = this;
        if (Object.prototype.hasOwnProperty.call(this.entity, 'properties')) {
            var library = this.entity;
            return {
                name: library.name,
                params: library.params.map(function (p) { return ({
                    name: p.name,
                    type: _this.resolve(p.type)
                }); }),
                properties: library.properties.map(function (p) { return ({
                    name: p.name,
                    type: _this.resolve(p.type)
                }); }),
                genericTypes: (this.entity.genericTypes || []).map(function (t) { return _this.resolve(t); })
            };
        }
        return {
            name: this.entity.name,
            params: this.entity.params.map(function (p) { return ({
                name: p.name,
                type: _this.resolve(p.type)
            }); }),
            genericTypes: (this.entity.genericTypes || []).map(function (t) { return _this.resolve(t); })
        };
    };
    GenericDeducer.prototype.assert = function (genericType, realType) {
        if (this.inferred[genericType]) {
            if (this.inferred[genericType] !== realType) {
                return new Error("Generic inference failed, generic ".concat(genericType, " cannot be both type ").concat(this.inferred[genericType], " and type ").concat(realType));
            }
        }
        else {
            this.inferred[genericType] = realType;
        }
    };
    return GenericDeducer;
}());
function deduceGenericStruct(param, entity, resolver) {
    if (!hasGeneric(entity)) {
        return entity;
    }
    var deducer = new GenericDeducer(entity, resolver);
    var error = deducer.inferr(param);
    if (error) {
        return error;
    }
    return deducer.getEntity();
}
exports.deduceGenericStruct = deduceGenericStruct;
function deduceGenericLibrary(param, entity, resolver) {
    if (!hasGeneric(entity)) {
        return entity;
    }
    var deducer = new GenericDeducer(entity, resolver);
    var error = deducer.inferr(param);
    if (error) {
        return error;
    }
    return deducer.getEntity();
}
exports.deduceGenericLibrary = deduceGenericLibrary;
function flatternArray(arg, param, resolver, options) {
    var _a = __read(arrayTypeAndSize(param.type), 2), elemTypeName = _a[0], arraySizes = _a[1];
    var typeInfo = resolver(elemTypeName);
    if (!options.ignoreValue) {
        if (!Array.isArray(arg)) {
            throw new Error('flatternArray only work with array');
        }
        if (arg.length != arraySizes[0]) {
            throw new Error("Array length not match, expected ".concat(arraySizes[0], " but got ").concat(arg.length));
        }
    }
    return new Array(arraySizes[0]).fill(1).flatMap(function (_, index) {
        var item = options.ignoreValue ? undefined : arg[index];
        if (arraySizes.length > 1) {
            return flatternArg({
                name: "".concat(param.name, "[").concat(index, "]"),
                type: subArrayType(param.type),
                value: item
            }, resolver, options);
        }
        else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
            return flatternArg({
                name: "".concat(param.name, "[").concat(index, "]"),
                type: elemTypeName,
                value: item
            }, resolver, options);
        }
        else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Library) {
            return flatternArg({
                name: "".concat(param.name, "[").concat(index, "]"),
                type: elemTypeName,
                value: item
            }, resolver, options);
        }
        return {
            value: item,
            name: "".concat(param.name).concat((0, internal_1.subscript)(index, arraySizes)),
            type: elemTypeName
        };
    });
}
function flatternStruct(arg, param, resolver, options) {
    var typeInfo = resolver(param.type);
    if (!options.ignoreValue) {
        if (typeof arg !== 'object') {
            throw new Error('flatternStruct only work with object');
        }
    }
    var entity = typeInfo.info;
    if (typeInfo.generic) {
        var deducer = new GenericDeducer(entity, resolver);
        var error = deducer.inferr(param);
        if (error) {
            throw error;
        }
        entity = deducer.getEntity();
    }
    return entity.params.flatMap(function (p) {
        var paramTypeInfo = resolver(p.type);
        var member = options.ignoreValue ? undefined : arg[p.name];
        if ((0, _1.isArrayType)(paramTypeInfo.finalType)) {
            return flatternArg({
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type,
                value: member
            }, resolver, options);
        }
        else if (paramTypeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
            return flatternArg({
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type,
                value: member
            }, resolver, options);
        }
        else {
            return {
                value: member,
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type
            };
        }
    });
}
function flatternLibrary(args, param, resolver, options) {
    var typeInfo = resolver(param.type);
    var entity = typeInfo.info;
    if (typeInfo.generic) {
        var deducer = new GenericDeducer(entity, resolver);
        var error = deducer.inferr(param);
        if (error) {
            throw error;
        }
        entity = deducer.getEntity();
    }
    if (!options.ignoreValue) {
        if (options.state) {
            if (typeof args !== 'object') {
                throw new Error('only work with object when flat a libray as state');
            }
        }
        else {
            if (!Array.isArray(args)) {
                throw new Error('only work with array when flat a library');
            }
            if (entity.params.length != args.length) {
                throw new Error("Array length not match, expected ".concat(entity.params.length, " but got ").concat(args.length));
            }
        }
    }
    var toflat = options.state ? entity.properties : entity.params;
    return toflat.flatMap(function (p, index) {
        var paramTypeInfo = resolver(p.type);
        var arg = options.ignoreValue ? undefined : (options.state ? args[p.name] : args[index]);
        if (!options.ignoreValue && typeof arg === 'undefined' && (entity.name === 'HashedSet' || entity.name === 'HashedMap')) {
            arg = args[0];
        }
        if ((0, _1.isArrayType)(paramTypeInfo.finalType)) {
            return flatternArg({
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type,
                value: arg
            }, resolver, options);
        }
        else if (paramTypeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
            return flatternArg({
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type,
                value: arg
            }, resolver, options);
        }
        else if (paramTypeInfo.symbolType === scryptTypes_1.SymbolType.Library) {
            return flatternArg({
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type,
                value: arg
            }, resolver, options);
        }
        else {
            return {
                value: arg,
                name: "".concat(param.name, ".").concat(p.name),
                type: p.type
            };
        }
    });
}
function flatternArg(arg, resolver, options) {
    var args_ = [];
    var typeInfo = resolver(arg.type);
    if ((0, _1.isArrayType)(typeInfo.finalType)) {
        flatternArray(options.ignoreValue ? undefined : arg.value, {
            name: arg.name,
            type: typeInfo.finalType
        }, resolver, options).forEach(function (e) {
            args_.push({
                name: e.name,
                type: resolver(e.type).finalType,
                value: e.value
            });
        });
    }
    else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Struct) {
        flatternStruct(arg.value, {
            name: arg.name,
            type: typeInfo.finalType
        }, resolver, options).forEach(function (e) {
            args_.push({
                name: e.name,
                type: resolver(e.type).finalType,
                value: e.value
            });
        });
    }
    else if (typeInfo.symbolType === scryptTypes_1.SymbolType.Library) {
        flatternLibrary(arg.value, {
            name: arg.name,
            type: typeInfo.finalType
        }, resolver, options).forEach(function (e) {
            args_.push({
                name: e.name,
                type: resolver(e.type).finalType,
                value: e.value
            });
        });
    }
    else {
        args_.push({
            name: arg.name,
            type: typeInfo.finalType,
            value: arg.value
        });
    }
    return args_;
}
exports.flatternArg = flatternArg;
function findConstStatic(statics, name) {
    return statics.find(function (s) {
        return s.const === true && s.name === name;
    });
}
exports.findConstStatic = findConstStatic;
function findStatic(statics, name) {
    return statics.find(function (s) {
        return s.name === name;
    });
}
exports.findStatic = findStatic;
function resolveAlias(alias, type) {
    var a = alias.find(function (a) {
        return a.name === type;
    });
    if (a) {
        return resolveAlias(alias, a.type);
    }
    return type;
}
function resolveType(type, originTypes, contract, statics, alias, librarys) {
    type = resolveAlias(alias, type);
    if ((0, _1.isArrayType)(type)) {
        var _a = __read(arrayTypeAndSizeStr(type), 2), elemTypeName = _a[0], sizes = _a[1];
        var elemTypeInfo = resolveType(elemTypeName, originTypes, contract, statics, alias, librarys);
        if ((0, _1.isArrayType)(elemTypeInfo.finalType)) {
            var _b = __read(arrayTypeAndSizeStr(elemTypeInfo.finalType), 2), elemTypeName_ = _b[0], sizes_ = _b[1];
            var elemTypeInfo_ = resolveType(elemTypeName_, originTypes, contract, statics, alias, librarys);
            return {
                info: elemTypeInfo.info,
                generic: elemTypeInfo.generic,
                finalType: resolveConstStatic(contract, toLiteralArrayType(elemTypeInfo_.finalType, sizes.concat(sizes_)), statics),
                symbolType: elemTypeInfo.symbolType
            };
        }
        return {
            info: elemTypeInfo.info,
            generic: elemTypeInfo.generic,
            finalType: resolveConstStatic(contract, toLiteralArrayType(elemTypeInfo.finalType, sizes), statics),
            symbolType: elemTypeInfo.symbolType
        };
    }
    else if (isGenericType(type)) {
        var _c = __read(parseGenericType(type), 2), name_2 = _c[0], genericTypes = _c[1];
        var typeInfo = resolveType(name_2, originTypes, contract, statics, alias, librarys);
        var gts = genericTypes.map(function (t) { return resolveType(t, originTypes, contract, statics, alias, librarys).finalType; });
        return {
            info: typeInfo.info,
            generic: true,
            finalType: (0, internal_1.toGenericType)(typeInfo.finalType, gts),
            symbolType: typeInfo.symbolType
        };
    }
    if (originTypes[type]) {
        return originTypes[type];
    }
    else if ((0, scryptTypes_1.isScryptType)(type)) {
        return {
            finalType: type,
            generic: false,
            symbolType: scryptTypes_1.SymbolType.ScryptType
        };
    }
    else {
        return {
            finalType: type,
            generic: false,
            symbolType: scryptTypes_1.SymbolType.Unknown
        };
    }
}
exports.resolveType = resolveType;
function resolveConstStatic(contract, type, statics) {
    if ((0, _1.isArrayType)(type)) {
        var _a = __read(arrayTypeAndSizeStr(type), 2), elemTypeName = _a[0], arraySizes = _a[1];
        var sizes = arraySizes.map(function (size) {
            if (/^(\d)+$/.test(size)) {
                return parseInt(size);
            }
            else {
                // size as a static const
                var size_ = (size.indexOf('.') > 0) ? size : "".concat(contract, ".").concat(size);
                var value = findConstStatic(statics, size_);
                if (!value) {
                    // Unable to solve when the subscript of the array is a function parameter, [CTC](https://scryptdoc.readthedocs.io/en/latest/ctc.html)
                    return size;
                }
                return value.value;
            }
        });
        return toLiteralArrayType(elemTypeName, sizes);
    }
    return type;
}
/**
 * check if a type is generic type
 * @param type
 * @returns
 */
function isGenericType(type) {
    return /^([\w]+)<([\w,[\]\s<>]+)>$/.test(type);
}
exports.isGenericType = isGenericType;
/**
 *
 * @param type eg. HashedMap<int,int>
 * @param eg. ["HashedMap", ["int", "int"]}] An array generic types returned by @getGenericDeclaration
 * @returns {"K": "int", "V": "int"}
 */
function parseGenericType(type) {
    if (isGenericType(type)) {
        var m = type.match(/([\w]+)<([\w,[\]<>\s]+)>$/);
        if (m) {
            var library = m[1];
            var realTypes = [];
            var brackets = [];
            var tmpType = '';
            for (var i = 0; i < m[2].length; i++) {
                var ch = m[2].charAt(i);
                if (ch === '<' || ch === '[') {
                    brackets.push(ch);
                }
                else if (ch === '>' || ch === ']') {
                    brackets.pop();
                }
                else if (ch === ',') {
                    if (brackets.length === 0) {
                        realTypes.push(tmpType.trim());
                        tmpType = '';
                        continue;
                    }
                }
                tmpType += ch;
            }
            realTypes.push(tmpType.trim());
            return [library, realTypes];
        }
    }
    throw new Error("\"".concat(type, "\" is not generic type"));
}
exports.parseGenericType = parseGenericType;
function resolveGenericType(genericTypeMap, type) {
    if (Object.keys(genericTypeMap).length > 0) {
        if (isGenericType(type)) {
            var _a = __read(parseGenericType(type), 2), name_3 = _a[0], types = _a[1];
            return (0, internal_1.toGenericType)(name_3, types.map(function (t) { return genericTypeMap[t] || t; }));
        }
        if ((0, _1.isArrayType)(type)) {
            var _b = __read(arrayTypeAndSizeStr(type), 2), elem = _b[0], sizes = _b[1];
            return toLiteralArrayType(elem, sizes.map(function (t) { return genericTypeMap[t] || t; }));
        }
        return genericTypeMap[type] || type;
    }
    return type;
}
exports.resolveGenericType = resolveGenericType;
//# sourceMappingURL=typeCheck.js.map