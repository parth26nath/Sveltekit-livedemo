"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSourceMapfromArtifact = exports.getStaticDeclaration = exports.getAliasDeclaration = exports.getContractDeclaration = exports.getLibraryDeclaration = exports.getStructDeclaration = exports.getABIDeclaration = exports.getContractName = exports.getFullFilePath = exports.compilerVersion = exports.handleCompilerOutput = exports.compile = exports.settings2cmd = exports.compileAsync = exports.doCompileAsync = exports.ABIEntityType = exports.DebugModeTag = exports.CompileResult = exports.BuildType = exports.CompileErrorType = exports.SOURCE_REG = void 0;
var child_process_1 = require("child_process");
var fs_1 = require("fs");
var path_1 = require("path");
var internal_1 = require("./internal");
var rimraf = require("rimraf");
var JSONbig = require("json-bigint");
var SYNTAX_ERR_REG = /(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):\n([^\n]+\n){3}(unexpected (?<unexpected>[^\n]+)\nexpecting (?<expecting>[^\n]+)|(?<message>[^\n]+))/g;
var SEMANTIC_ERR_REG = /Error:(\s|\n)*(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+):*\n(?<message>[^\n]+)\n/g;
var INTERNAL_ERR_REG = /Internal error:(?<message>.+)/;
var WARNING_REG = /Warning:(\s|\n)*(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+):*\n(?<message>[^\n]+)\n/g;
var JSONbigAlways = JSONbig({ alwaysParseAsBig: true, constructorAction: 'preserve' });
//SOURCE_REG parser src eg: [0:6:3:8:4#Bar.constructor:0]
exports.SOURCE_REG = /^(?<fileIndex>-?\d+):(?<line>\d+):(?<col>\d+):(?<endLine>\d+):(?<endCol>\d+)(#(?<tagStr>.+))?/;
var RELATED_INFORMATION_REG = /(?<filePath>[^\s]+):(?<line>\d+):(?<column>\d+):(?<line1>\d+):(?<column1>\d+)/gi;
// see VERSIONLOG.md
var CompileErrorType;
(function (CompileErrorType) {
    CompileErrorType["SyntaxError"] = "SyntaxError";
    CompileErrorType["SemanticError"] = "SemanticError";
    CompileErrorType["InternalError"] = "InternalError";
    CompileErrorType["Warning"] = "Warning";
})(CompileErrorType = exports.CompileErrorType || (exports.CompileErrorType = {}));
var BuildType;
(function (BuildType) {
    BuildType["Debug"] = "debug";
    BuildType["Release"] = "release";
})(BuildType = exports.BuildType || (exports.BuildType = {}));
var CompileResult = /** @class */ (function () {
    function CompileResult(errors, warnings) {
        this.errors = errors;
        this.warnings = warnings;
    }
    CompileResult.prototype.toArtifact = function () {
        var artifact = {
            version: internal_1.CURRENT_CONTRACT_ARTIFACT_VERSION,
            compilerVersion: this.compilerVersion || '0.0.0',
            contract: this.contract || '',
            md5: this.md5 || '',
            structs: this.structs || [],
            library: this.library || [],
            alias: this.alias || [],
            abi: this.abi || [],
            stateProps: this.stateProps || [],
            buildType: this.buildType || BuildType.Debug,
            file: this.file || '',
            hex: this.hex || '',
            asm: '',
            sourceMap: [],
            sources: [],
            sourceMapFile: this.sourceMapFile || '',
        };
        return artifact;
    };
    return CompileResult;
}());
exports.CompileResult = CompileResult;
var DebugModeTag;
(function (DebugModeTag) {
    DebugModeTag["FuncStart"] = "F0";
    DebugModeTag["FuncEnd"] = "F1";
    DebugModeTag["LoopStart"] = "L0";
})(DebugModeTag = exports.DebugModeTag || (exports.DebugModeTag = {}));
var ABIEntityType;
(function (ABIEntityType) {
    ABIEntityType["FUNCTION"] = "function";
    ABIEntityType["CONSTRUCTOR"] = "constructor";
})(ABIEntityType = exports.ABIEntityType || (exports.ABIEntityType = {}));
function toOutputDir(artifactsDir, sourcePath) {
    return (0, path_1.join)(artifactsDir, (0, path_1.basename)(sourcePath) + '-' + (0, internal_1.hash160)(sourcePath, 'utf-8').substring(0, 10));
}
function doCompileAsync(source, settings, callback) {
    var sourcePath = source.path;
    var srcDir = (0, path_1.dirname)(sourcePath);
    var curWorkingDir = settings.cwd || srcDir;
    var timeout = settings.timeout || 1200000;
    var sourceContent = source.content !== undefined ? source.content : (0, fs_1.readFileSync)(sourcePath, 'utf8');
    var cmd = settings2cmd(sourcePath, settings);
    var childProcess = (0, child_process_1.exec)(cmd, { cwd: curWorkingDir, timeout: timeout, killSignal: 'SIGKILL' }, function (error, stdout) {
        if (error) {
            console.error("exec error: ".concat(error, " stdout: ").concat(stdout));
            callback(error, null);
            return;
        }
        callback(null, {
            path: sourcePath,
            output: stdout,
            md5: (0, internal_1.md5)(sourceContent),
        });
    });
    childProcess.stdin.write(sourceContent, function (error) {
        if (error) {
            callback(error, null);
            return;
        }
        childProcess.stdin.end();
    });
    return childProcess;
}
exports.doCompileAsync = doCompileAsync;
function compileAsync(source, settings) {
    var _this = this;
    settings = Object.assign({}, defaultCompilingSettings, settings);
    return new Promise(function (resolve, reject) {
        doCompileAsync(source, settings, function (error, data) { return __awaiter(_this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                if (error) {
                    reject(error);
                    return [2 /*return*/];
                }
                try {
                    result = handleCompilerOutput(source.path, settings, data.output, data.md5);
                    resolve(result);
                }
                catch (error) {
                    reject(error);
                }
                return [2 /*return*/];
            });
        }); });
    });
}
exports.compileAsync = compileAsync;
var defaultCompilingSettings = {
    ast: true,
    asm: false,
    hex: true,
    debug: false,
    artifact: false,
    outputDir: '',
    outputToFiles: false,
    cwd: '',
    cmdPrefix: '',
    cmdArgs: '',
    buildType: BuildType.Debug,
    stdout: false,
    sourceMap: false,
    timeout: 1200000 // in ms
};
function settings2cmd(sourcePath, settings) {
    var srcDir = (0, path_1.dirname)(sourcePath);
    //dir that store artifact file
    var artifactDir = settings.outputDir || srcDir;
    //dir that store ast,asm file
    var outputDir = toOutputDir(artifactDir, sourcePath);
    var cmdPrefix = settings.cmdPrefix || (0, internal_1.findCompiler)();
    var outOption = "-o \"".concat(outputDir, "\"");
    if (settings.stdout) {
        outOption = '--stdout';
        return "\"".concat(cmdPrefix, "\" compile ").concat(settings.asm || settings.artifact ? '--asm' : '', " ").concat(settings.hex ? '--hex' : '', " ").concat(settings.ast || settings.artifact ? '--ast' : '', " ").concat(settings.debug == true ? '--debug' : '', " -r ").concat(outOption, " ").concat(settings.cmdArgs ? settings.cmdArgs : '');
    }
    else {
        if (!(0, fs_1.existsSync)(outputDir)) {
            (0, fs_1.mkdirSync)(outputDir);
        }
    }
    return "\"".concat(cmdPrefix, "\" compile ").concat(settings.hex ? '--hex' : '', " ").concat(settings.ast || settings.artifact ? '--ast' : '', " ").concat(settings.debug == true ? '--debug' : '', " ").concat(settings.sourceMap == true ? '--source-map' : '', " -r ").concat(outOption, " ").concat(settings.cmdArgs ? settings.cmdArgs : '');
}
exports.settings2cmd = settings2cmd;
function compile(source, settings) {
    var sourcePath = source.path;
    var srcDir = (0, path_1.dirname)(sourcePath);
    //dir that stores artifact file
    var curWorkingDir = settings.cwd || srcDir;
    settings = Object.assign({}, defaultCompilingSettings, settings);
    var sourceContent = source.content !== undefined ? source.content : (0, fs_1.readFileSync)(sourcePath, 'utf8');
    var maxBuffer = settings.stdout ? 1024 * 1024 * 100 : 1024 * 1024;
    settings = Object.assign({}, defaultCompilingSettings, settings);
    var cmd = settings2cmd(sourcePath, settings);
    var output = (0, child_process_1.execSync)(cmd, { input: sourceContent, cwd: curWorkingDir, timeout: settings.timeout, maxBuffer: maxBuffer }).toString();
    return handleCompilerOutput(sourcePath, settings, output, (0, internal_1.md5)(sourceContent));
}
exports.compile = compile;
function handleCompilerOutput(sourcePath, settings, output, md5) {
    var srcDir = (0, path_1.dirname)(sourcePath);
    var sourceFileName = (0, path_1.basename)(sourcePath);
    var artifactsDir = settings.outputDir || srcDir;
    var outputDir = toOutputDir(artifactsDir, sourcePath);
    var outputFiles = {};
    try {
        // Because the output of the compiler on the win32 platform uses crlf as a newline， here we change \r\n to \n. make SYNTAX_ERR_REG、SEMANTIC_ERR_REG、IMPORT_ERR_REG work.
        output = output.split(/\r?\n/g).join('\n');
        var result = new CompileResult([], []);
        result.compilerVersion = compilerVersion(settings.cmdPrefix ? settings.cmdPrefix : (0, internal_1.findCompiler)());
        result.md5 = md5;
        result.buildType = settings.buildType || BuildType.Debug;
        if (output.startsWith('Error:') || output.startsWith('Warning:')) {
            Object.assign(result, getErrorsAndWarnings(output, srcDir, sourceFileName));
            if (result.errors.length > 0) {
                return result;
            }
            if (settings.stdout && result.warnings.length > 0) { // stdout not allowed warnings
                return result;
            }
        }
        if (settings.stdout) {
            var stdout = JSONbigAlways.parse(output);
            parserAst(result, stdout.ast, srcDir, sourceFileName, sourcePath);
            parserASM(result, stdout.asm, settings, srcDir, sourceFileName);
        }
        else {
            if (settings.ast || settings.artifact) {
                var outputFilePath = getOutputFilePath(outputDir, 'ast');
                var astFile = outputFilePath.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                (0, fs_1.renameSync)(outputFilePath, astFile);
                outputFiles['ast'] = astFile;
                var ast = JSONbigAlways.parse((0, fs_1.readFileSync)(astFile, 'utf8'));
                parserAst(result, ast, srcDir, sourceFileName, sourcePath);
            }
            if (settings.hex || settings.artifact) {
                var outputFilePath = getOutputFilePath(outputDir, 'hex');
                var hexFile = outputFilePath.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                (0, fs_1.renameSync)(outputFilePath, hexFile);
                outputFiles['hex'] = hexFile;
                result.hex = (0, fs_1.readFileSync)(hexFile, 'utf8');
            }
            if (settings.sourceMap) {
                var outputFilePath = getOutputFilePath(outputDir, 'map');
                if (settings.artifact) {
                    var dist = getOutputFilePath(artifactsDir, 'map');
                    var sourceMapFile = dist.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                    (0, fs_1.renameSync)(outputFilePath, sourceMapFile);
                    result.sourceMapFile = (0, internal_1.path2uri)(sourceMapFile);
                }
                else {
                    var sourceMapFile = outputFilePath.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                    (0, fs_1.renameSync)(outputFilePath, sourceMapFile);
                    outputFiles['map'] = sourceMapFile;
                    result.sourceMapFile = (0, internal_1.path2uri)(sourceMapFile);
                }
            }
            if (settings.debug) {
                var outputFilePath = getOutputFilePath(outputDir, 'dbg');
                var dbgFile = outputFilePath.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                (0, fs_1.renameSync)(outputFilePath, dbgFile);
                result.dbgFile = (0, internal_1.path2uri)(dbgFile);
            }
            if (settings.artifact) {
                var outputFilePath = getOutputFilePath(artifactsDir, 'artifact');
                var artifactFile = outputFilePath.replace('stdin', (0, path_1.basename)(sourcePath, '.scrypt'));
                var artifact = result.toArtifact();
                (0, fs_1.writeFileSync)(artifactFile, JSON.stringify(artifact, function (key, value) {
                    //ignore deprecated fields
                    if (key == 'sources' || key == 'sourceMap' || key === 'asm')
                        return undefined;
                    else
                        return value;
                }, 4));
            }
        }
        return result;
    }
    finally {
        doClean(settings, outputFiles, outputDir);
    }
}
exports.handleCompilerOutput = handleCompilerOutput;
function compilerVersion(cwd) {
    try {
        var text = (0, child_process_1.execSync)("\"".concat(cwd, "\" version")).toString();
        return /Version:\s*([^\s]+)\s*/.exec(text)[1];
    }
    catch (e) {
        throw new Error("compilerVersion fail when run: ".concat(cwd, " version"));
    }
}
exports.compilerVersion = compilerVersion;
function addSourceLocation(astRoot, basePath, curFileName) {
    for (var fileName in astRoot) {
        if (fileName === 'std') {
            astRoot['std'] = _addSourceLocationProperty(astRoot['std'], 'std');
        }
        else {
            var realFileName = fileName === 'stdin' ? curFileName : fileName;
            var uri = (0, internal_1.path2uri)((0, path_1.join)(basePath, realFileName));
            astRoot[uri] = _addSourceLocationProperty(astRoot[fileName], uri);
            delete astRoot[fileName];
        }
    }
    return astRoot;
}
function _addSourceLocationProperty(astObj, uri) {
    if (!(typeof astObj === 'object')) {
        return astObj;
    }
    for (var field in astObj) {
        var value = astObj[field];
        if (field === 'src') {
            var matches = /:(\d+):(\d+):(\d+):(\d+)/.exec(value);
            if (!matches) {
                astObj.loc = null;
            }
            else {
                astObj.loc = {
                    source: uri,
                    start: { line: parseInt(matches[1]), column: parseInt(matches[2]) },
                    end: { line: parseInt(matches[3]), column: parseInt(matches[4]) }
                };
            }
            delete astObj['src'];
        }
        else if (typeof value === 'object') {
            _addSourceLocationProperty(value, uri);
        }
    }
    return astObj;
}
function getOutputFilePath(baseDir, target) {
    if (target == 'hex') {
        return (0, path_1.join)(baseDir, "stdin_".concat(target, ".txt"));
    }
    else if (target === 'map') {
        return (0, path_1.join)(baseDir, "stdin.".concat(target, ".json"));
    }
    else if (target === 'dbg') {
        return (0, path_1.join)(baseDir, "stdin.".concat(target, ".json"));
    }
    else if (target === 'artifact') {
        return (0, path_1.join)(baseDir, 'stdin.json');
    }
    return (0, path_1.join)(baseDir, "stdin_".concat(target, ".json"));
}
function getFullFilePath(relativePath, baseDir, curFileName) {
    if (relativePath.endsWith('stdin')) {
        return (0, path_1.join)(baseDir, curFileName); // replace 'stdin' with real current compiling file name.
    }
    if (relativePath === 'std') {
        return 'std'; // 
    }
    return (0, path_1.join)(baseDir, relativePath);
}
exports.getFullFilePath = getFullFilePath;
function getConstructorDeclaration(mainContract) {
    // explict constructor
    if (mainContract['constructor']) {
        return {
            type: ABIEntityType.CONSTRUCTOR,
            params: mainContract['constructor']['params'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
        };
    }
    else {
        // implicit constructor
        if (mainContract['properties']) {
            return {
                type: ABIEntityType.CONSTRUCTOR,
                params: mainContract['properties'].map(function (p) { return { name: p['name'].replace('this.', ''), type: p['type'] }; }),
            };
        }
    }
}
function getStateProps(astRoot) {
    var mainContract = astRoot['contracts'][astRoot['contracts'].length - 1];
    if (mainContract && mainContract['properties']) {
        return mainContract['properties'].filter(function (p) { return p.state; }).map(function (p) { return { name: p['name'].replace('this.', ''), type: p['type'] }; });
    }
    return [];
}
function getPublicFunctionDeclaration(mainContract) {
    var pubIndex = 0;
    var interfaces = mainContract['functions']
        .filter(function (f) { return f['visibility'] === 'Public'; })
        .map(function (f) {
        var entity = {
            type: ABIEntityType.FUNCTION,
            name: f['name'],
            index: f['nodeType'] === 'Constructor' ? undefined : pubIndex++,
            params: f['params'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
        };
        return entity;
    });
    return interfaces;
}
function getContractName(astRoot) {
    var mainContract = astRoot['contracts'][astRoot['contracts'].length - 1];
    if (!mainContract) {
        return '';
    }
    return mainContract['name'] || '';
}
exports.getContractName = getContractName;
function shortGenericType(genericType) {
    var m = genericType.match(/__SCRYPT_(\w+)__/);
    if (m) {
        return m[1];
    }
    return genericType;
}
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param typeResolver a Type Resolver
 * @returns All function ABIs defined by the main contract, including constructors
 */
function getABIDeclaration(astRoot, typeResolver) {
    var mainContract = astRoot['contracts'][astRoot['contracts'].length - 1];
    if (!mainContract) {
        return {
            contract: '',
            abi: []
        };
    }
    var interfaces = getPublicFunctionDeclaration(mainContract);
    var constructorABI = getConstructorDeclaration(mainContract);
    interfaces.push(constructorABI);
    interfaces.forEach(function (abi) {
        abi.params = abi.params.map(function (param) {
            return Object.assign(param, {
                type: typeResolver(param.type).finalType
            });
        });
    });
    return {
        contract: getContractName(astRoot),
        abi: interfaces
    };
}
exports.getABIDeclaration = getABIDeclaration;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined structures of the main contract and dependent contracts
 */
function getStructDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    return allAst.map(function (ast) {
        return (ast['structs'] || []).map(function (s) { return ({
            name: s['name'],
            params: s['fields'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
            genericTypes: s.genericTypes || [],
        }); });
    }).flat(1);
}
exports.getStructDeclaration = getStructDeclaration;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined Library of the main contract and dependent contracts
 */
function getLibraryDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        if (key !== 'std') {
            allAst.push(dependencyAsts[key]);
        }
    });
    return allAst.map(function (ast) {
        return (ast['contracts'] || []).filter(function (c) { return c.nodeType == 'Library'; }).map(function (c) {
            if (c['constructor']) {
                return {
                    name: c.name,
                    params: c['constructor']['params'].map(function (p) { return { name: "ctor.".concat(p['name']), type: p['type'] }; }),
                    properties: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                    genericTypes: c.genericTypes || [],
                };
            }
            else {
                // implicit constructor
                if (c['properties']) {
                    return {
                        name: c.name,
                        params: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                        properties: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                        genericTypes: c.genericTypes || [],
                    };
                }
            }
        });
    }).flat(1);
}
exports.getLibraryDeclaration = getLibraryDeclaration;
function getContractDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        if (key !== 'std') {
            allAst.push(dependencyAsts[key]);
        }
    });
    return allAst.map(function (ast) {
        return (ast['contracts'] || []).filter(function (c) { return c.nodeType == 'Contract'; }).map(function (c) {
            if (c['constructor']) {
                return {
                    name: c.name,
                    params: c['constructor']['params'].map(function (p) { return { name: "ctor.".concat(p['name']), type: p['type'] }; }),
                    properties: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                    genericTypes: c.genericTypes || []
                };
            }
            else {
                // implicit constructor
                if (c['properties']) {
                    return {
                        name: c.name,
                        params: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                        properties: c['properties'].map(function (p) { return { name: p['name'], type: p['type'] }; }),
                        genericTypes: c.genericTypes || [],
                    };
                }
            }
        });
    }).flat(1);
}
exports.getContractDeclaration = getContractDeclaration;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined type aliaes of the main contract and dependent contracts
 */
function getAliasDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    return allAst.map(function (ast) {
        return (ast['alias'] || []).map(function (s) { return ({
            name: s['alias'],
            type: s['type'],
        }); });
    }).flat(1);
}
exports.getAliasDeclaration = getAliasDeclaration;
/**
 *
 * @param astRoot AST root node after main contract compilation
 * @param dependencyAsts AST root node after all dependency contract compilation
 * @returns all defined static const int literal of the main contract and dependent contracts
 */
function getStaticDeclaration(astRoot, dependencyAsts) {
    var allAst = [astRoot];
    Object.keys(dependencyAsts).forEach(function (key) {
        allAst.push(dependencyAsts[key]);
    });
    return allAst.map(function (ast) {
        return (ast['contracts'] || []).map(function (contract) {
            return (contract.statics || []).map(function (node) {
                return {
                    const: node.const,
                    name: "".concat(contract.name, ".").concat(node.name),
                    type: node.type,
                    value: (0, internal_1.resolveConstValue)(node)
                };
            });
        });
    }).flat(Infinity).flat(1);
}
exports.getStaticDeclaration = getStaticDeclaration;
function getRelatedInformation(message, srcDir, sourceFileName) {
    var _a, _b, _c, _d;
    var relatedInformation = [];
    var result;
    while ((result = RELATED_INFORMATION_REG.exec(message))) {
        var relatedFilePath = result.groups.filePath;
        if (relatedFilePath === 'null')
            continue;
        var fullFilePath = getFullFilePath(relatedFilePath, srcDir, sourceFileName);
        var line = parseInt(((_a = result.groups) === null || _a === void 0 ? void 0 : _a.line) || '-1');
        var column = parseInt(((_b = result.groups) === null || _b === void 0 ? void 0 : _b.column) || '-1');
        relatedInformation.push({
            filePath: fullFilePath,
            position: [{
                    line: line,
                    column: column,
                }, {
                    line: parseInt(((_c = result.groups) === null || _c === void 0 ? void 0 : _c.line1) || '-1'),
                    column: parseInt(((_d = result.groups) === null || _d === void 0 ? void 0 : _d.column1) || '-1'),
                }],
            message: ''
        });
        message = message.replace(/([^\s]+):(\d+):(\d+):(\d+):(\d+)/, '');
    }
    return {
        relatedInformation: relatedInformation,
        message: message
    };
}
function getErrorsAndWarnings(output, srcDir, sourceFileName) {
    var _a;
    var warnings = __spreadArray([], __read(output.matchAll(WARNING_REG)), false).map(function (match) {
        var _a, _b, _c, _d, _e, _f;
        var filePath = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.filePath) || '';
        var origin_message = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.message) || '';
        var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
        return {
            type: CompileErrorType.Warning,
            filePath: getFullFilePath(filePath, srcDir, sourceFileName),
            position: [{
                    line: parseInt(((_c = match.groups) === null || _c === void 0 ? void 0 : _c.line) || '-1'),
                    column: parseInt(((_d = match.groups) === null || _d === void 0 ? void 0 : _d.column) || '-1'),
                }, {
                    line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line1) || '-1'),
                    column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column1) || '-1'),
                }],
            message: message,
            relatedInformation: relatedInformation
        };
    });
    if (output.match(INTERNAL_ERR_REG)) {
        var errors = [{
                type: CompileErrorType.InternalError,
                filePath: getFullFilePath('stdin', srcDir, sourceFileName),
                message: "Compiler internal error: ".concat(((_a = output.match(INTERNAL_ERR_REG).groups) === null || _a === void 0 ? void 0 : _a.message) || ''),
                position: [{
                        line: 1,
                        column: 1
                    }, {
                        line: 1,
                        column: 1
                    }],
                relatedInformation: []
            }];
        return new CompileResult(errors, warnings);
    }
    else if (output.includes('Syntax error:')) {
        var syntaxErrors = __spreadArray([], __read(output.matchAll(SYNTAX_ERR_REG)), false).map(function (match) {
            var _a, _b, _c, _d, _e, _f;
            var filePath = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.filePath) || '';
            var unexpected = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.unexpected) || '';
            var expecting = ((_c = match.groups) === null || _c === void 0 ? void 0 : _c.expecting) || '';
            var origin_message = ((_d = match.groups) === null || _d === void 0 ? void 0 : _d.message) || "unexpected ".concat(unexpected, "\nexpecting ").concat(expecting);
            var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
            return {
                type: CompileErrorType.SyntaxError,
                filePath: getFullFilePath(filePath, srcDir, sourceFileName),
                position: [{
                        line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line) || '-1'),
                        column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column) || '-1'),
                    }],
                message: message,
                unexpected: unexpected,
                expecting: expecting,
                relatedInformation: relatedInformation
            };
        });
        return new CompileResult(syntaxErrors, warnings);
    }
    else {
        var semanticErrors = __spreadArray([], __read(output.matchAll(SEMANTIC_ERR_REG)), false).map(function (match) {
            var _a, _b, _c, _d, _e, _f;
            var origin_message = ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.message) || '';
            var filePath = ((_b = match.groups) === null || _b === void 0 ? void 0 : _b.filePath) || '';
            var _g = getRelatedInformation(origin_message, srcDir, sourceFileName), message = _g.message, relatedInformation = _g.relatedInformation;
            return {
                type: CompileErrorType.SemanticError,
                filePath: getFullFilePath(filePath, srcDir, sourceFileName),
                position: [{
                        line: parseInt(((_c = match.groups) === null || _c === void 0 ? void 0 : _c.line) || '-1'),
                        column: parseInt(((_d = match.groups) === null || _d === void 0 ? void 0 : _d.column) || '-1'),
                    }, {
                        line: parseInt(((_e = match.groups) === null || _e === void 0 ? void 0 : _e.line1) || '-1'),
                        column: parseInt(((_f = match.groups) === null || _f === void 0 ? void 0 : _f.column1) || '-1'),
                    }],
                message: message,
                relatedInformation: relatedInformation
            };
        });
        return new CompileResult(semanticErrors, warnings);
    }
}
function parserAst(result, ast, srcDir, sourceFileName, sourcePath) {
    var allAst = addSourceLocation(ast, srcDir, sourceFileName);
    var sourceUri = (0, internal_1.path2uri)(sourcePath);
    result.file = sourceUri;
    result.ast = allAst[sourceUri];
    delete allAst[sourceUri];
    result.dependencyAsts = allAst;
    var alias = getAliasDeclaration(result.ast, allAst);
    var structs = getStructDeclaration(result.ast, allAst);
    var library = getLibraryDeclaration(result.ast, allAst);
    var statics = getStaticDeclaration(result.ast, allAst);
    result.contracts = getContractDeclaration(result.ast, allAst);
    var typeResolver = (0, internal_1.buildTypeResolver)(getContractName(result.ast), alias, structs, library, result.contracts, statics);
    result.alias = alias.map(function (a) { return ({
        name: a.name,
        type: typeResolver(a.type).finalType
    }); });
    result.structs = structs.map(function (a) { return ({
        name: a.name,
        params: a.params.map(function (p) { return ({ name: p.name, type: typeResolver(p.type).finalType }); }),
        genericTypes: a.genericTypes.map(function (t) { return shortGenericType(t); })
    }); });
    result.library = library.map(function (a) { return ({
        name: a.name,
        params: a.params.map(function (p) { return ({ name: p.name, type: typeResolver(p.type).finalType }); }),
        properties: a.properties.map(function (p) { return ({ name: p.name, type: typeResolver(p.type).finalType }); }),
        genericTypes: a.genericTypes.map(function (t) { return shortGenericType(t); })
    }); });
    result.statics = statics.map(function (s) { return (Object.assign(__assign({}, s), {
        type: typeResolver(s.type).finalType
    })); });
    var _a = getABIDeclaration(result.ast, typeResolver), name = _a.contract, abi = _a.abi;
    result.stateProps = getStateProps(result.ast).map(function (p) { return ({ name: p.name, type: typeResolver(p.type).finalType }); });
    result.abi = abi;
    result.contract = name;
}
/**
 * @deprecated use `--hex` when compiling
 * @param result
 * @param asmObj
 * @param settings
 * @param srcDir
 * @param sourceFileName
 */
function parserASM(result, asmObj, settings, srcDir, sourceFileName) {
    var sources = asmObj.sources;
    if (settings.debug) {
        Object.assign(result, {
            file: result.file,
            sources: asmObj.sources.map(function (source) { return getFullFilePath(source, srcDir, sourceFileName); }),
            sourceMap: asmObj.output.map(function (item) { return item.src; }),
        });
    }
    result.hex = settings.hex ? asmObj.output.map(function (item) { return item.hex; }).join('') : '';
    result.asm = asmObj.output.map(function (item) {
        if (!settings.debug) {
            return {
                opcode: item.opcode
            };
        }
        var match = exports.SOURCE_REG.exec(item.src);
        if (match && match.groups) {
            var fileIndex = parseInt(match.groups.fileIndex);
            var debugInfo = void 0;
            var tagStr = match.groups.tagStr;
            var m = /^(\w+)\.(\w+):(\d)(#(?<context>.+))?$/.exec(tagStr);
            if (m) {
                debugInfo = {
                    contract: m[1],
                    func: m[2],
                    tag: m[3] == '0' ? DebugModeTag.FuncStart : DebugModeTag.FuncEnd,
                    context: m.groups.context
                };
            }
            else if (/loop:0/.test(tagStr)) {
                debugInfo = {
                    contract: '',
                    func: '',
                    tag: DebugModeTag.LoopStart,
                    context: ''
                };
            }
            var pos = sources[fileIndex] ? {
                file: sources[fileIndex] ? getFullFilePath(sources[fileIndex], srcDir, sourceFileName) : undefined,
                line: sources[fileIndex] ? parseInt(match.groups.line) : undefined,
                endLine: sources[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                column: sources[fileIndex] ? parseInt(match.groups.col) : undefined,
                endColumn: sources[fileIndex] ? parseInt(match.groups.endCol) : undefined,
            } : undefined;
            return {
                opcode: item.opcode,
                stack: item.stack,
                topVars: item.topVars || [],
                pos: pos,
                debugInfo: debugInfo
            };
        }
        throw new Error('Compile Failed: Asm output parsing Error!');
    });
    if (settings.debug) {
        result.autoTypedVars = asmObj.autoTypedVars.map(function (item) {
            var match = exports.SOURCE_REG.exec(item.src);
            if (match && match.groups) {
                var fileIndex = parseInt(match.groups.fileIndex);
                var pos = sources[fileIndex] ? {
                    file: sources[fileIndex] ? getFullFilePath(sources[fileIndex], srcDir, sourceFileName) : undefined,
                    line: sources[fileIndex] ? parseInt(match.groups.line) : undefined,
                    endLine: sources[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                    column: sources[fileIndex] ? parseInt(match.groups.col) : undefined,
                    endColumn: sources[fileIndex] ? parseInt(match.groups.endCol) : undefined,
                } : undefined;
                return {
                    name: item.name,
                    type: item.type,
                    pos: pos
                };
            }
        });
    }
}
function doClean(settings, outputFiles, outputDir) {
    if (settings.stdout || settings.outputToFiles || settings.sourceMap) {
        return;
    }
    try {
        Object.keys(outputFiles).forEach(function (outputType) {
            var file = outputFiles[outputType];
            if ((0, fs_1.existsSync)(file)) {
                (0, fs_1.unlinkSync)(file);
            }
        });
        rimraf.sync(outputDir);
    }
    catch (error) {
        console.error('clean compiler output files failed!');
    }
    // console.log('compile time spent: ', Date.now() - st)
}
function loadSourceMapfromArtifact(artifact) {
    var sources = artifact.sources;
    var asm = artifact.asm.split(' ');
    if (!artifact.sourceMap || artifact.sourceMap.length == 0) {
        return [];
    }
    return asm.map(function (opcode, index) {
        var item = artifact.sourceMap[index];
        var match = exports.SOURCE_REG.exec(item);
        if (match && match.groups) {
            var fileIndex = parseInt(match.groups.fileIndex);
            var pos = sources[fileIndex] ? {
                file: sources[fileIndex],
                line: sources[fileIndex] ? parseInt(match.groups.line) : undefined,
                endLine: sources[fileIndex] ? parseInt(match.groups.endLine) : undefined,
                column: sources[fileIndex] ? parseInt(match.groups.col) : undefined,
                endColumn: sources[fileIndex] ? parseInt(match.groups.endCol) : undefined,
            } : undefined;
            return {
                pos: pos,
                opcode: opcode
            };
        }
    });
}
exports.loadSourceMapfromArtifact = loadSourceMapfromArtifact;
//# sourceMappingURL=compilerWrapper.js.map