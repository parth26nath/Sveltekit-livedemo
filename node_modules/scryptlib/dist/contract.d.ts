import { LibraryEntity, ParamEntity } from '.';
import { ContractEntity, OpCode, StaticEntity } from './compilerWrapper';
import { ABICoder, ABIEntity, AliasEntity, Arguments, bsv, CompileResult, FunctionCall, Script, StructEntity, TypeResolver } from './internal';
import { Bytes, SupportedParamType } from './scryptTypes';
/**
 * TxContext provides some context information of the current transaction,
 * needed only if signature is checked inside the contract.
 */
export interface TxContext {
    /** current transaction represented in bsv.Transaction object or hex string */
    tx: bsv.Transaction | string;
    /** input index */
    inputIndex: number;
    /** input amount in satoshis */
    inputSatoshis: number;
    /** contract state in ASM format */
    opReturn?: string;
    /** contract state in hex format */
    opReturnHex?: string;
}
export type VerifyError = string;
export type ContractClass = typeof AbstractContract;
export type Contract = AbstractContract;
export interface VerifyResult {
    success: boolean;
    error?: VerifyError;
}
export declare const CURRENT_CONTRACT_ARTIFACT_VERSION = 9;
export declare const SUPPORTED_MINIMUM_VERSION = 8;
export interface Artifact {
    /** version of artifact file */
    version: number;
    /** version of compiler used to produce this file */
    compilerVersion: string;
    /** build type, can be debug or release */
    buildType: string;
    /** name of the contract */
    contract: string;
    /** md5 of the contract source code */
    md5: string;
    /** all stateful properties defined in the contracts */
    stateProps: Array<ParamEntity>;
    /** all structures defined in the contracts, including dependent contracts */
    structs: Array<StructEntity>;
    /** all library defined in the contracts, including dependent contracts */
    library: Array<LibraryEntity>;
    /** all typealias defined in the contracts, including dependent contracts */
    alias: Array<AliasEntity>;
    /** ABI of the contract: interfaces of its public functions and constructor */
    abi: Array<ABIEntity>;
    /** @deprecated locking script of the contract in ASM format, including placeholders for constructor parameters */
    asm?: string;
    /** locking script of the contract in hex format, including placeholders for constructor parameters */
    hex: string;
    /** file uri of the main contract source code file */
    file: string;
    /** @deprecated **/
    sources?: Array<string>;
    /** @deprecated **/
    sourceMap?: Array<string>;
    /** file uri of source map file **/
    sourceMapFile: string;
}
/** NOPScript */
export type NOPScript = bsv.Script;
export type AsmVarValues = {
    [key: string]: string;
};
export type StepIndex = number;
export declare class AbstractContract {
    static artifact: Artifact;
    static opcodes?: OpCode[];
    static hex: string;
    static abi: ABIEntity[];
    static abiCoder: ABICoder;
    static stateProps: Array<ParamEntity>;
    static asmContract: boolean;
    static resolver: TypeResolver;
    constructor(...ctorParams: SupportedParamType[]);
    [key: string]: any;
    scriptedConstructor: FunctionCall;
    private calledPubFunctions;
    hasInlineASMVars: boolean;
    hexTemplateInlineASM: Map<string, string>;
    hexTemplateArgs: Map<string, string>;
    statePropsArgs: Arguments;
    isGenesis: boolean;
    nopScript: NOPScript | null;
    get lockingScript(): Script;
    private _wrapNOPScript;
    private _txContext?;
    set txContext(txContext: TxContext | undefined);
    get txContext(): TxContext | undefined;
    get sourceMapFile(): string;
    get file(): string;
    get contractName(): string;
    get stateProps(): ParamEntity[];
    get version(): number;
    addFunctionCall(f: FunctionCall): void;
    get resolver(): TypeResolver;
    replaceAsmVars(asmVarValues: AsmVarValues): void;
    get asmArgs(): AsmVarValues;
    /**
   * @param states an object. Each key of the object is the name of a state property, and each value is the value of the state property.
   * @returns a locking script that includes the new states. If you only provide some but not all state properties, other state properties are not modified when calculating the locking script.
   */
    getNewStateScript(states: Record<string, SupportedParamType>): Script;
    run_verify(unlockingScript: bsv.Script | string | undefined, txContext?: TxContext): VerifyResult;
    /**
     * format the error
     * @param err the result output by  `tx.verifyInputScript(inputIndex)`
     * @returns string the formatted error message.
     */
    fmtError(err: {
        error: string;
        failedAt: {
            fExec: boolean;
            opcode: number;
            pc: number;
        };
    }): string;
    /**
     * Generate a debugger launch configuration for the contract's last called public method
     * @param txContext
     * @returns a uri of the debugger launch configuration
     */
    genLaunchConfig(txContext?: TxContext): string;
    private _dataPartInHex;
    set dataPart(dataInScript: Script | undefined);
    get dataPart(): Script | undefined;
    /**
   * @deprecated use setDataPartInASM setDataPartInHex
   * set the data part of the contract
   * @param state
   * @param isStateHex
   */
    setDataPart(state: string, isStateHex?: boolean): void;
    /**
   * set the data part of the contract in ASM format
   * @param asm
   * @param
   */
    setDataPartInASM(asm: string): void;
    /**
   * set the data part of the contract in hex format
   * @param hex
   */
    setDataPartInHex(hex: string): void;
    prependNOPScript(nopScript: NOPScript | null): void;
    getPrependNOPScript(): NOPScript | null;
    get codePart(): Script;
    get codeHash(): string;
    static getAsmVars(lockingScriptHex: string): AsmVarValues;
    arguments(pubFuncName: string): Arguments;
    private lastCalledPubFunction;
    ctorArgs(): Arguments;
    /**
       * Get the parameter of the constructor and inline asm vars,
       * all values is hex string, need convert it to number or bytes on using
       */
    get asmVars(): AsmVarValues | null;
    get ContractClass(): typeof AbstractContract;
    private transformerArgs;
    private transformerArg;
    checkArgs(funname: string, params: ParamEntity[], ...args: SupportedParamType[]): SupportedParamType[];
    static fromASM(asm: string): AbstractContract;
    static fromHex(hex: string): AbstractContract;
    static fromTransaction(hex: string, outputIndex?: number): AbstractContract;
    static isStateful(contract: AbstractContract): boolean;
    static flattenSha256(data: SupportedParamType, type: string): string;
    private static sortmap;
    private static sortset;
    private static sortkeys;
    static findKeyIndex(collection: Map<SupportedParamType, SupportedParamType> | Set<SupportedParamType>, key: SupportedParamType, keyType: string): bigint;
    static toData(collection: Map<SupportedParamType, SupportedParamType> | Set<SupportedParamType>, collectionType: string): Bytes;
}
export declare function buildContractClass(artifact: Artifact | CompileResult): typeof AbstractContract;
export declare function buildTypeResolverFromArtifact(artifact: Artifact): TypeResolver;
export declare function buildTypeResolver(contract: string, alias: AliasEntity[], structs: StructEntity[], library: LibraryEntity[], contracts?: ContractEntity[], statics?: StaticEntity[]): TypeResolver;
