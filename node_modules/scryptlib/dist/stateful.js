"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var deserializer_1 = require("./deserializer");
var internal_1 = require("./internal");
var scryptTypes_1 = require("./scryptTypes");
var Stateful = /** @class */ (function () {
    function Stateful() {
    }
    Stateful.int2hex = function (n) {
        var asm = '';
        var num = new _1.bsv.crypto.BN(n);
        if (num.eqn(0)) {
            asm = '00';
        }
        else {
            asm = num.toSM({ endian: 'little' }).toString('hex');
        }
        return _1.bsv.Script.fromASM(asm).toHex();
    };
    Stateful.hex2int = function (hex) {
        var s = _1.bsv.Script.fromHex(hex);
        var chuck = s.chunks[0];
        return (0, _1.bin2num)(chuck.buf.toString('hex'));
    };
    Stateful.bool2hex = function (b) {
        if (b) {
            return '01';
        }
        return '00';
    };
    Stateful.hex2bool = function (hex) {
        if (hex === '01') {
            return true;
        }
        else if (hex === '00') {
            return false;
        }
        throw new Error("invalid hex ".concat(hex));
    };
    Stateful.bytes2hex = function (b) {
        if (b === '') {
            return '00';
        }
        return _1.bsv.Script.fromASM(b).toHex();
    };
    Stateful.hex2bytes = function (hex) {
        if (hex === '00') {
            return '';
        }
        var s = _1.bsv.Script.fromHex(hex);
        var chuck = s.chunks[0];
        return chuck.buf.toString('hex');
    };
    Stateful.toHex = function (x, type) {
        if (type === scryptTypes_1.ScryptType.INT || type === scryptTypes_1.ScryptType.PRIVKEY) {
            return Stateful.int2hex(x);
        }
        else if (type === scryptTypes_1.ScryptType.BOOL) {
            return Stateful.bool2hex(x);
        }
        else if ((0, scryptTypes_1.isBytes)(type)) {
            return Stateful.bytes2hex(x);
        }
        throw new Error("unsupported type: ".concat(type));
    };
    Stateful.serialize = function (x, type) {
        if (type === scryptTypes_1.ScryptType.INT || type === scryptTypes_1.ScryptType.PRIVKEY) {
            var num = new _1.bsv.crypto.BN(x);
            if (num.eqn(0)) {
                return '';
            }
            else {
                return num.toSM({ endian: 'little' }).toString('hex');
            }
        }
        else if (type === scryptTypes_1.ScryptType.BOOL) {
            if (x) {
                return '01';
            }
            return '';
        }
        else if ((0, scryptTypes_1.isBytes)(type)) {
            return x;
        }
        throw new Error("unsupported type: ".concat(type));
    };
    /**
   * only used for state contract
   * @param args
   * @param isGenesis
   * @param finalTypeResolver
   * @returns
   */
    Stateful.buildState = function (args, isGenesis, resolver) {
        var args_ = args.map(function (arg) {
            return (0, internal_1.flatternArg)(arg, resolver, { state: true, ignoreValue: false });
        }).flat(Infinity);
        if (args_.length <= 0) {
            throw new Error('no state property found, buildContractState only used for state contract');
        }
        // append isGenesis which is a hidden built-in state
        var state_hex = "".concat(Stateful.toHex(isGenesis, scryptTypes_1.ScryptType.BOOL));
        state_hex += args_.map(function (a) { return Stateful.toHex(a.value, a.type); }).join('');
        //append meta
        if (state_hex) {
            var state_len = state_hex.length / 2;
            state_hex += (0, _1.num2bin)(BigInt(state_len), 4) + (0, _1.num2bin)(Stateful.CURRENT_STATE_VERSION, 1);
            return state_hex;
        }
        return state_hex;
    };
    Stateful.buildDefaultStateArgs = function (contract) {
        var dummyArgs = contract.stateProps.map(function (p) {
            var dummyArg = Object.assign({}, p, { value: false });
            return (0, internal_1.flatternArg)(dummyArg, contract.resolver, { state: true, ignoreValue: true });
        }).flat(Infinity);
        var hexTemplateMap = new Map();
        dummyArgs.forEach(function (p) {
            if (p.type === scryptTypes_1.ScryptType.INT || p.type === scryptTypes_1.ScryptType.PRIVKEY) {
                hexTemplateMap.set("<".concat(p.name, ">"), Stateful.int2hex((0, scryptTypes_1.Int)(0)));
            }
            else if (p.type === scryptTypes_1.ScryptType.BOOL) {
                hexTemplateMap.set("<".concat(p.name, ">"), Stateful.bool2hex(true));
            }
            else if (p.type === scryptTypes_1.ScryptType.BYTES
                || p.type === scryptTypes_1.ScryptType.PUBKEY
                || p.type === scryptTypes_1.ScryptType.SIG
                || p.type === scryptTypes_1.ScryptType.RIPEMD160
                || p.type === scryptTypes_1.ScryptType.SHA1
                || p.type === scryptTypes_1.ScryptType.SHA256
                || p.type === scryptTypes_1.ScryptType.SIGHASHTYPE
                || p.type === scryptTypes_1.ScryptType.SIGHASHPREIMAGE
                || p.type === scryptTypes_1.ScryptType.OPCODETYPE) {
                hexTemplateMap.set("<".concat(p.name, ">"), Stateful.bytes2hex('00'));
            }
            else {
                throw new Error("param ".concat(p.name, " has unknown type ").concat(p.type));
            }
        });
        return contract.stateProps.map(function (param) { return (0, deserializer_1.deserializeArgfromHex)(contract.resolver, Object.assign(param, {
            value: undefined
        }), hexTemplateMap, { state: true }); });
    };
    Stateful.deserializer = function (type, hex) {
        switch (type) {
            case scryptTypes_1.ScryptType.BOOL:
                return (0, scryptTypes_1.Bool)(Stateful.hex2bool(hex));
            case scryptTypes_1.ScryptType.INT:
                return (0, scryptTypes_1.Int)(Stateful.hex2int(hex));
            case scryptTypes_1.ScryptType.BYTES:
                return (0, scryptTypes_1.Bytes)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.PRIVKEY:
                return (0, scryptTypes_1.PrivKey)(Stateful.hex2int(hex));
            case scryptTypes_1.ScryptType.PUBKEY:
                return (0, scryptTypes_1.PubKey)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.SIG:
                return (0, scryptTypes_1.Sig)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.RIPEMD160:
                return (0, scryptTypes_1.Ripemd160)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.SHA1:
                return (0, scryptTypes_1.Sha1)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.SHA256:
                return (0, scryptTypes_1.Sha256)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.SIGHASHTYPE:
                return (0, scryptTypes_1.SigHashType)(Number(Stateful.hex2int(hex)));
            case scryptTypes_1.ScryptType.SIGHASHPREIMAGE:
                return (0, scryptTypes_1.SigHashPreimage)(Stateful.hex2bytes(hex));
            case scryptTypes_1.ScryptType.OPCODETYPE:
                return (0, scryptTypes_1.OpCodeType)(Stateful.hex2bytes(hex));
            default:
                throw new Error("<".concat(type, "> cannot be cast to ScryptType, only sCrypt native types supported"));
        }
    };
    Stateful.readBytes = function (br) {
        try {
            var opcodenum = br.readUInt8();
            var len = void 0, data = void 0;
            if (opcodenum == 0) {
                data = '';
            }
            else if (opcodenum > 0 && opcodenum < _1.bsv.Opcode.OP_PUSHDATA1) {
                len = opcodenum;
                data = br.read(len).toString('hex');
            }
            else if (opcodenum === _1.bsv.Opcode.OP_PUSHDATA1) {
                len = br.readUInt8();
                data = br.read(len).toString('hex');
            }
            else if (opcodenum === _1.bsv.Opcode.OP_PUSHDATA2) {
                len = br.readUInt16LE();
                data = br.read(len).toString('hex');
            }
            else if (opcodenum === _1.bsv.Opcode.OP_PUSHDATA4) {
                len = br.readUInt32LE();
                data = br.read(len).toString('hex');
            }
            else {
                data = (0, _1.num2bin)(BigInt(opcodenum - 80), 1);
            }
            return {
                data: data,
                opcodenum: opcodenum
            };
        }
        catch (e) {
            throw new Error('readBytes: ' + e);
        }
    };
    Stateful.parseStateHex = function (contract, scriptHex) {
        var metaScript = scriptHex.substr(scriptHex.length - 10, 10);
        /* eslint-disable @typescript-eslint/no-unused-vars */
        var version = Number((0, _1.bin2num)(metaScript.substr(metaScript.length - 2, 2)));
        var stateLen = Number((0, _1.bin2num)(metaScript.substr(0, 8)));
        var stateHex = scriptHex.substr(scriptHex.length - 10 - stateLen * 2, stateLen * 2);
        var br = new _1.bsv.encoding.BufferReader(Buffer.from(stateHex, 'hex'));
        var opcodenum = br.readUInt8();
        var isGenesis = opcodenum == 1;
        var stateTemplateArgs = new Map();
        var dummyArgs = contract.stateProps.map(function (p) {
            var dummyArg = Object.assign({}, p, { value: false });
            return (0, internal_1.flatternArg)(dummyArg, contract.resolver, { state: true, ignoreValue: true });
        }).flat(Infinity);
        dummyArgs.forEach(function (param) {
            if (param.type === scryptTypes_1.ScryptType.BOOL) {
                var opcodenum_1 = br.readUInt8();
                stateTemplateArgs.set("<".concat(param.name, ">"), opcodenum_1 === 1 ? '01' : '00');
            }
            else {
                var data = Stateful.readBytes(br).data;
                stateTemplateArgs.set("<".concat(param.name, ">"), data ? _1.bsv.Script.fromASM(data).toHex() : '00');
            }
        });
        var args = contract.stateProps.map(function (param) { return Object.assign({}, param, {
            value: false
        }); }).map(function (arg) {
            return (0, deserializer_1.deserializeArgfromHex)(contract.resolver, arg, stateTemplateArgs, { state: true });
        });
        return [isGenesis, args];
    };
    // state version
    Stateful.CURRENT_STATE_VERSION = (0, scryptTypes_1.Int)(0);
    return Stateful;
}());
exports.default = Stateful;
//# sourceMappingURL=stateful.js.map