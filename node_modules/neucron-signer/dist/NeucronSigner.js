"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeucronSigner = void 0;
const axios_1 = __importDefault(require("axios"));
const scrypt_ts_1 = require("scrypt-ts");
const scrypt_ts_2 = require("scrypt-ts");
// import { UTXO } from 'scrypt-ts';
const scrypt_ts_3 = require("scrypt-ts");
const scryptlib_1 = require("scryptlib");
const NeucronWalletAPI_1 = require("./neucron/NeucronWalletAPI");
class NeucronSigner extends scrypt_ts_2.Signer {
    constructor(provider, authToken, neucron) {
        super(provider);
        this.login = async (email, password) => {
            try {
                const requestBody = {
                    email: email,
                    password: password,
                };
                const response = await axios_1.default.post('https://dev.neucron.io/v1/auth/login', requestBody, {
                    headers: {
                        accept: 'application/json',
                        'Content-Type': 'application/json',
                    },
                });
                const responseBody = await response.data;
                if (responseBody.data && responseBody.data.access_token) {
                    const authToken = responseBody.data.access_token;
                    const neucron = new NeucronWalletAPI_1.NeucronWalletAPI(authToken);
                    this._target = neucron;
                }
                else {
                    throw new Error('Invalid response structure.');
                }
            }
            catch (error) {
                if (error instanceof Error) {
                    throw new Error('Login failed: ' + error.message);
                }
                else {
                    throw new Error('Login failed: ' + error.toString());
                }
            }
        };
        if (authToken !== undefined && authToken) {
            neucron = new NeucronWalletAPI_1.NeucronWalletAPI(authToken);
        }
        if (neucron !== undefined && neucron) {
            this._target = neucron;
        }
    }
    /**
     * Check if the wallet has been authenticated
     * @returns {boolean} true | false
     */
    isAuthenticated() {
        if (this._target) {
            return this._target.isConnect();
        }
        return Promise.resolve(false);
    }
    /**
     * Request wallet authentication
     * @returns A promise which resolves to if the wallet has been authenticated and the authenticate error message
     */
    async requestAuth() {
        let isAuthenticated = false;
        let error = '';
        try {
            await this.getConnectedTarget();
            isAuthenticated = true;
        }
        catch (e) {
            error = e.toString();
        }
        return Promise.resolve({ isAuthenticated, error });
    }
    async getConnectedTarget() {
        const isAuthenticated = await this.isAuthenticated();
        if (!isAuthenticated) {
            // trigger connecting to neucron account when it's not authorized.
            try {
                const addr = await this._target.requestAccount();
                this._address = scrypt_ts_3.bsv.Address.fromString(addr);
            }
            catch (e) {
                throw new Error('neucron requestAccount failed');
            }
        }
        return this._target;
    }
    async connect(provider) {
        // we should make sure neucron is connected  before we connect a provider.
        const isAuthenticated = await this.isAuthenticated();
        if (!isAuthenticated) {
            throw new Error('neucron is not connected!');
        }
        if (provider) {
            if (!provider.isConnected()) {
                await provider.connect();
            }
            this.provider = provider;
        }
        else {
            if (this.provider) {
                await this.provider.connect();
            }
            else {
                throw new Error(`No provider found`);
            }
        }
        return this;
    }
    async getDefaultAddress() {
        const neucron = await this.getConnectedTarget();
        const address = await neucron.getAddress();
        return scrypt_ts_3.bsv.Address.fromString(address);
    }
    async getNetwork() {
        const address = await this.getDefaultAddress();
        return address.network;
    }
    getBalance(address) {
        if (address) {
            return this.connectedProvider.getBalance(address);
        }
        return this.getConnectedTarget()
            .then((target) => target.getBsvBalance())
            .then((r) => r.balance);
    }
    async getDefaultPubKey() {
        const neucron = await this.getConnectedTarget();
        const pubKey = await neucron.getPublicKey();
        return Promise.resolve(new scrypt_ts_3.bsv.PublicKey(pubKey));
    }
    async getPubKey(address) {
        throw new Error(`Method ${this.constructor.name}#getPubKey not implemented.`);
    }
    async signRawTransaction(rawTxHex, options) {
        const sigReqsByInputIndex = ((options === null || options === void 0 ? void 0 : options.sigRequests) || []).reduce((m, sigReq) => {
            m.set(sigReq.inputIndex, sigReq);
            return m;
        }, new Map());
        const tx = new scrypt_ts_3.bsv.Transaction(rawTxHex);
        tx.inputs.forEach((_, inputIndex) => {
            const sigReq = sigReqsByInputIndex.get(inputIndex);
            if (!sigReq) {
                throw new Error(`\`SignatureRequest\` info should be provided for the input ${inputIndex} to call #signRawTransaction`);
            }
            const script = sigReq.scriptHex
                ? new scrypt_ts_3.bsv.Script(sigReq.scriptHex)
                : scrypt_ts_3.bsv.Script.buildPublicKeyHashOut(sigReq.address.toString());
            // set ref output of the input
            tx.inputs[inputIndex].output = new scrypt_ts_3.bsv.Transaction.Output({
                script,
                satoshis: sigReq.satoshis,
            });
        });
        const signedTx = await this.signTransaction(tx, options);
        return signedTx.toString();
    }
    async signTransaction(tx, options) {
        var _a;
        const network = await this.getNetwork();
        // Generate default `sigRequests` if not passed by user
        const sigRequests = ((_a = options === null || options === void 0 ? void 0 : options.sigRequests) === null || _a === void 0 ? void 0 : _a.length)
            ? options.sigRequests
            : tx.inputs.map((input, inputIndex) => {
                var _a, _b, _c, _d, _e, _f, _g;
                const useAddressToSign = (options && options.address) || (input.output && input.output.script.isPublicKeyHashOut())
                    ? (_c = (_a = options === null || options === void 0 ? void 0 : options.address) !== null && _a !== void 0 ? _a : (_b = input.output) === null || _b === void 0 ? void 0 : _b.script.toAddress(network)) !== null && _c !== void 0 ? _c : this._address
                    : this._address;
                return {
                    prevTxId: (0, scrypt_ts_1.toHex)(input.prevTxId),
                    outputIndex: input.outputIndex,
                    inputIndex,
                    satoshis: (_e = (_d = input.output) === null || _d === void 0 ? void 0 : _d.satoshis) !== null && _e !== void 0 ? _e : 0,
                    address: useAddressToSign,
                    scriptHex: (_g = (_f = input.output) === null || _f === void 0 ? void 0 : _f.script) === null || _g === void 0 ? void 0 : _g.toHex(),
                    sigHashType: scryptlib_1.DEFAULT_SIGHASH_TYPE,
                };
            });
        const sigResponses = await this.getSignatures(tx.toString(), sigRequests);
        // Set the acquired signature as an unlocking script for the transaction
        tx.inputs.forEach((input, inputIndex) => {
            var _a;
            // TODO: multisig?
            const sigResp = sigResponses.find((sigResp) => sigResp.inputIndex === inputIndex);
            if (sigResp && ((_a = input.output) === null || _a === void 0 ? void 0 : _a.script.isPublicKeyHashOut())) {
                const unlockingScript = new scrypt_ts_3.bsv.Script('')
                    .add(Buffer.from(sigResp.sig, 'hex'))
                    .add(Buffer.from(sigResp.publicKey, 'hex'));
                input.setScript(unlockingScript);
            }
        });
        return tx;
    }
    async signMessage(message, address) {
        if (address) {
            throw new Error(`${this.constructor.name}#signMessge with \`address\` param is not supported!`);
        }
        const neucron = await this.getConnectedTarget();
        return neucron.signMessage(message);
    }
    async getSignatures(rawTxHex, sigRequests) {
        const network = await this.getNetwork();
        const inputInfos = sigRequests.flatMap((sigReq) => {
            const addresses = (0, scrypt_ts_1.parseAddresses)(sigReq.address, network);
            return addresses.map((address) => {
                let scriptHex = sigReq.scriptHex;
                if (!scriptHex) {
                    scriptHex =
                        scrypt_ts_3.bsv.Script.buildPublicKeyHashOut(address).toHex();
                }
                else if (sigReq.csIdx !== undefined) {
                    scriptHex = scrypt_ts_3.bsv.Script.fromHex(scriptHex)
                        .subScript(sigReq.csIdx)
                        .toHex();
                }
                return {
                    txHex: rawTxHex,
                    inputIndex: sigReq.inputIndex,
                    scriptHex,
                    satoshis: sigReq.satoshis,
                    sigtype: sigReq.sigHashType || scryptlib_1.DEFAULT_SIGHASH_TYPE,
                    address: address.toString(),
                };
            });
        });
        const neucron = await this.getConnectedTarget();
        const sigResults = await neucron.signTx({
            list: inputInfos,
        });
        return inputInfos.map((inputInfo, idx) => {
            return {
                inputIndex: inputInfo.inputIndex,
                sig: sigResults.sigList[idx].sig,
                publicKey: sigResults.sigList[idx].publicKey,
                sigHashType: sigRequests[idx].sigHashType || scryptlib_1.DEFAULT_SIGHASH_TYPE,
            };
        });
    }
}
exports.NeucronSigner = NeucronSigner;
NeucronSigner.DEBUG_TAG = 'NeucronSigner';
