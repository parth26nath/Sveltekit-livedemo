import { AddressOption, Provider } from 'scrypt-ts';
import { Signer, SignatureRequest, SignatureResponse, SignTransactionOptions } from 'scrypt-ts';
import { bsv } from 'scrypt-ts';
import { PublicKey, Transaction } from 'bsv';
import { INeucronWalletAPI } from './neucron/INeucronWalletAPI';
export declare class NeucronSigner extends Signer {
    static readonly DEBUG_TAG = "NeucronSigner";
    private _target;
    private _address;
    constructor(provider: Provider, authToken?: string, neucron?: INeucronWalletAPI);
    login: (email: string, password: string) => Promise<void>;
    /**
     * Check if the wallet has been authenticated
     * @returns {boolean} true | false
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Request wallet authentication
     * @returns A promise which resolves to if the wallet has been authenticated and the authenticate error message
     */
    requestAuth(): Promise<{
        isAuthenticated: boolean;
        error: string;
    }>;
    private getConnectedTarget;
    connect(provider?: Provider): Promise<this>;
    getDefaultAddress(): Promise<bsv.Address>;
    getNetwork(): Promise<bsv.Networks.Network>;
    getBalance(address?: AddressOption): Promise<{
        confirmed: number;
        unconfirmed: number;
    }>;
    getDefaultPubKey(): Promise<PublicKey>;
    getPubKey(address: AddressOption): Promise<PublicKey>;
    signRawTransaction(rawTxHex: string, options: SignTransactionOptions): Promise<string>;
    signTransaction(tx: Transaction, options?: SignTransactionOptions): Promise<Transaction>;
    signMessage(message: string, address?: AddressOption): Promise<string>;
    getSignatures(rawTxHex: string, sigRequests: SignatureRequest[]): Promise<SignatureResponse[]>;
}
//# sourceMappingURL=NeucronSigner.d.ts.map